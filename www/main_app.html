<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <script src="./www-config.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ShapeFIT">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="ShapeFIT">
    <meta name="theme-color" content="transparent">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Script Critical -->
    <script>
        function setRealViewportHeight() { 
            const vh = window.innerHeight * 0.01; 
            document.documentElement.style.setProperty('--vh', `${vh}px`); 
        }
        setRealViewportHeight();
        window.addEventListener('resize', setRealViewportHeight);
        window.addEventListener('orientationchange', function() {
            setTimeout(setRealViewportHeight, 100);
        });
        
        if (window.visualViewport) {
            const updateKeyboardOffset = () => {
                const viewportHeight = window.visualViewport.height;
                const offset = Math.max(0, window.innerHeight - viewportHeight);
                document.documentElement.style.setProperty('--keyboard-offset', `${offset}px`);
            };
            
            window.visualViewport.addEventListener('resize', updateKeyboardOffset);
            window.visualViewport.addEventListener('scroll', updateKeyboardOffset);
            window.addEventListener('orientationchange', updateKeyboardOffset);
            updateKeyboardOffset();
        }
        
        document.addEventListener('touchmove', function(event) {
            const checkinModal = document.getElementById('checkinModal');
            const isModalOpen = checkinModal && checkinModal.classList.contains('active');
            
            if (isModalOpen) {
                const insideMessages = event.target.closest('#checkinMessages');
                if (insideMessages) {
                    // Permitir scroll dentro do chat
                    return;
                }
                
                const insideModal = event.target.closest('#checkinModal');
                if (insideModal) {
                    // Dentro do modal mas fora das mensagens -> bloquear
                    event.preventDefault();
                    return;
                }
            }
            
            const scrollable = event.target.closest('.app-container, .container');
            if (!scrollable) {
                event.preventDefault();
            }
        }, { passive: false });
    </script>
    
    <title>Dashboard - ShapeFIT</title>
    
    <!-- Fontes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Ícones -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    
    <!-- Lottie.js para animações dos banners -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <!-- CSS Principal -->
    <link rel="stylesheet" href="./assets/css/style.css">
    <link rel="stylesheet" href="./assets/css/pages/_dashboard.css">
    
    <!-- Variáveis Globais -->
    <script>
        // BASE_APP_URL já foi definido pelo www-config.js
        // Se não foi definido (fallback), usar URL local
        if (!window.BASE_APP_URL) {
            window.BASE_APP_URL = window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/');
            if (window.BASE_APP_URL.endsWith('/')) {
                window.BASE_APP_URL = window.BASE_APP_URL.slice(0, -1);
            }
        }
    </script>
    
    <!-- Auth Script -->
    <script src="./assets/js/auth.js"></script>
    <!-- SPA Navigation - Mantém background e navbar fixos -->
    <script src="./assets/js/spa-navigation.js"></script>
    <!-- App State - Gerencia estado para evitar recarregamentos -->
    <script src="./assets/js/app-state.js"></script>
    
    <style>
        :root {
            --keyboard-offset: 0px;
        }
        
        html, body {
            min-height: 100%;
        }
        
        body {
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            overflow-x: hidden;
        }
        
        body.checkin-modal-open {
            overflow: hidden;
        }
        
        a, button, .btn, [role="button"] {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
    
    <style>
        .lottie-animation-container {
        width: 100%;
        height: 100%;
    }
    .main-carousel .lottie-slide.active {
        opacity: 1 !important;
    }
</style>

<style>
/* CSS do layout moderno */
.header{display:flex;justify-content:flex-end;align-items:center}.header-actions{display:flex;align-items:center;gap:.75rem}.points-counter-badge{display:flex;align-items:center;gap:8px;height:44px;padding:0 16px;border-radius:22px;background-color:var(--surface-color);border:1px solid var(--border-color);color:var(--text-primary);text-decoration:none;transition:all .2s ease}.points-counter-badge:hover{border-color:var(--accent-orange)}.points-counter-badge i{color:var(--accent-orange);font-size:1rem}.points-counter-badge span{font-weight:600;font-size:1rem}
.profile-icon{display:flex;align-items:center;justify-content:center;width:44px;height:44px;border-radius:50%;border:1px solid var(--border-color);background-color:var(--surface-color);overflow:hidden;transition:border-color .2s ease}
.profile-icon:hover{border-color:var(--accent-orange)}
.profile-icon img{width:100%;height:100%;object-fit:cover}
.profile-icon i{color:var(--accent-orange);font-size:1.2rem;}

/* ============================================== */
/* --- CSS PARA OS CARDS INDIVIDUAIS DE RESUMO --- */
/* ============================================== */
.card-weight { display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; position: relative; gap: 4px; padding: 24px; }
.card-weight span { font-size: 0.9rem; color: var(--text-secondary); }
.card-weight strong { font-size: 2.2rem; line-height: 1.2; color: var(--text-primary); }
.card-weight .countdown { font-size: 2rem; }
.card-weight .edit-button { position: absolute; top: 16px; right: 16px; background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 5px; transition: color 0.2s ease; }
.card-weight .edit-button:hover { color: var(--accent-orange); }
.card-weight .edit-button svg { width: 20px; height: 20px; }

.card-hydration { padding: 20px 24px; overflow: hidden; }
.card-hydration .hydration-content { display: grid; grid-template-columns: minmax(0,1fr) 160px; align-items: center; gap: 12px; }
.card-hydration .hydration-info { flex-grow: 1; display: flex; flex-direction: column; min-width: 0; }
.card-hydration h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--text-primary); }
.card-hydration .water-status { font-size: 1.5rem; font-weight: 600; color: var(--text-primary); margin-bottom: 15px; }
.card-hydration .water-status span:last-child { font-size: 1rem; color: var(--text-secondary); }
.card-hydration .water-controls { display: flex; flex-direction: column; gap: 12px; }
.card-hydration .water-input-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
.card-hydration .inline-input-row { display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; margin-left: 24px; }
.card-hydration .water-number-input { width: 120px; padding: 12px 14px; border-radius: 14px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.05); color: var(--text-primary); font-weight: 600; text-align: center; }
.card-hydration .water-number-input::placeholder { color: rgba(255,255,255,0.35); }
.card-hydration .circle-btn { width: 64px; height: 64px; border-radius: 50%; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.06); color: var(--text-primary); font-size: 1.8rem; font-weight: 700; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; }
.card-hydration .circle-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.2); }
.card-hydration .circle-btn.accent { border: none; background-image: var(--primary-orange-gradient); color: var(--text-primary); }
.card-hydration .circle-btn:disabled { opacity: 0.5; cursor: default; filter: grayscale(0.2); }
/* Wrapper para o select de água com setinha customizada */
.card-hydration .water-select-wrapper {
    position: relative;
    display: inline-block;
    min-width: 78px;
}

.card-hydration .water-select { 
    padding: 10px 32px 10px 12px; /* Espaço extra à direita para a setinha */
    border-radius: 14px; 
    border: 1px solid var(--glass-border); 
    background: rgba(255,255,255,0.05); 
    color: var(--text-primary); 
    font-weight: 700; 
    text-transform: uppercase; 
    width: 100%;
    min-width: 78px;
    /* Remover setinha padrão do navegador */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    cursor: pointer;
    transition: border-color 0.2s ease;
}

.card-hydration .water-select:focus {
    outline: none;
    border-color: var(--accent-orange);
}

/* Setinha customizada branca usando Font Awesome */
.card-hydration .water-select-arrow {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    color: var(--text-primary);
    font-size: 0.75rem;
    opacity: 0.8;
    transition: opacity 0.2s ease, color 0.2s ease;
}

.card-hydration .water-select-wrapper:hover .water-select-arrow {
    opacity: 1;
}

.card-hydration .water-select:focus + .water-select-arrow {
    color: var(--accent-orange);
    opacity: 1;
}
.card-hydration .full-btn { width: 100%; padding: 12px 16px; border-radius: 14px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.06); color: var(--text-primary); font-weight: 700; cursor: pointer; text-align: center; }
.card-hydration .quick-add-row { display: flex; flex-wrap: wrap; gap: 8px; }
.card-hydration .quick-add { padding: 8px 12px; border-radius: 999px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.06); color: var(--text-primary); font-weight: 600; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; }
.card-hydration .quick-add:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.2); }
.card-hydration .water-drop-container-svg { width: 160px; height: 160px; display: flex; align-items: center; justify-content: center; justify-self: end; }
.card-hydration .water-controls { margin-top: 8px; }
.card-hydration .water-input-row { flex-wrap: wrap; }
.card-hydration .water-input-row > * { flex: 0 0 auto; }
.card-hydration .quick-add-row { margin-top: 4px; }
.card-hydration .divider { width: 100%; height: 1px; background: var(--glass-border); margin: 6px 0 2px; opacity: 0.6; }


/* ======================================= */
/* --- CORREÇÃO PARA O CARD DE ÁGUA MOBILE --- */
/* ======================================= */
@media (max-width: 480px) {
    .card-hydration {
        padding: 20px 24px; /* Padding uniforme */
    }
    .card-hydration .hydration-content {
        /* Muda para layout de coluna em telas pequenas */
        grid-template-columns: 1fr;
        gap: 20px;
    }
    .card-hydration .water-drop-container-svg {
        /* Centraliza a gota d'água */
        justify-self: center;
        width: 150px; /* Levemente menor para caber melhor */
        height: 150px;
        order: -1; /* Coloca a gota no topo */
    }
    .card-hydration .hydration-info {
        /* Centraliza todo o bloco de informações */
        align-items: center;
        text-align: center;
    }
    .card-hydration .water-controls,
    .card-hydration .water-input-row,
    .card-hydration .inline-input-row {
        /* Centraliza os controles */
        justify-content: center;
        margin-left: 0; /* Remove a margem que estava causando o deslocamento */
    }
     .card-hydration .inline-input-row {
        /* Garante que o input e o select fiquem bem alinhados */
        width: 100%;
    }
    .card-hydration .water-number-input {
        /* Ocupa o espaço disponível para evitar quebra de linha */
        flex-grow: 1;
    }
}


/* Transição suave para o movimento do grupo do nível da água */
#animated-water-drop #water-level-group { 
    transition: transform 0.7s cubic-bezier(0.65, 0, 0.35, 1);
}

/* Animação das ondas da água */
@keyframes wave-animation {
    0% { transform: translateX(0); }
    50% { transform: translateX(-100px); }
    100% { transform: translateX(0); }
}
@keyframes wave-animation-2 {
    0% { transform: translateX(0); }
    50% { transform: translateX(100px); }
    100% { transform: translateX(0); }
}
#animated-water-drop #wave1 {
    animation: wave-animation 8s linear infinite;
}
#animated-water-drop #wave2 {
    animation: wave-animation-2 10s linear infinite alternate;
}

/* Corrige flicker/preto em mobile ao abrir o select: remove filtros e animações pesadas em telas touch */
@media (hover: none) and (pointer: coarse) {
    #animated-water-drop #water-level-group { filter: none !important; }
    #animated-water-drop #wave1,
    #animated-water-drop #wave2 { animation: none !important; }
}

/* Esta regra força os cards específicos a ocuparem a largura total do grid */
.card-weight,
.card-hydration,
.card-consumption,
.card-missions,
.card-meal-cta,
.card-suggestions,
.card-challenges,
.card-action-item {
    grid-column: 1 / -1;
}

/* ======================================= */
/* --- CSS DOS NOVOS CARDS DE AÇÃO --- */
/* ======================================= */
.card-action-item {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 20px 24px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
}

.card-action-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(255, 107, 53, 0.15);
}

.card-action-item .action-icon {
    width: 56px;
    height: 56px;
    border-radius: 14px;
    background: rgba(255, 255, 255, 0.06);
    display: flex;
    align-items: stretch;
    justify-content: flex-end;
    flex-shrink: 0;
    transition: all 0.3s ease;
}

.card-action-item .action-icon.premium {
    background: var(--primary-orange-gradient);
}

.card-action-item .action-icon i {
    font-size: 1.5rem;
    color: var(--accent-orange);
}

.card-action-item .action-icon.premium i {
    color: var(--text-primary);
}

.card-action-item:hover .action-icon {
    transform: scale(1.1);
}

.card-action-item .action-content {
    flex: 1;
    min-width: 0;
}

.card-action-item .action-content h3 {
    margin: 0 0 4px 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.card-action-item .action-content p {
    margin: 0;
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
}

.card-action-item .action-button {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.06);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.3s ease;
    color: var(--text-secondary);
    text-decoration: none;
}

.card-action-item:hover .action-button {
    background: var(--primary-orange-gradient);
    color: var(--text-primary);
    transform: translateX(4px);
}

.card-action-item .action-button i {
    font-size: 1rem;
}

/* Responsive */
@media (max-width: 480px) {
    .card-action-item {
        padding: 18px 20px;
        gap: 14px;
    }
    
    .card-action-item .action-icon {
        width: 48px;
        height: 48px;
    }
    
    .card-action-item .action-icon i {
        font-size: 1.3rem;
    }
    
    .card-action-item .action-content h3 {
        font-size: 1rem;
    }
    
    .card-action-item .action-content p {
        font-size: 0.8rem;
    }
}

/* Estilos para o modal de duração de exercício */
.duration-input-group {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-top: 8px;
}

.duration-input-group input {
    flex: 1;
    padding: 12px 16px;
    border-radius: 8px;
    border: 1px solid var(--glass-border);
    background: rgba(255,255,255,0.05);
    color: var(--text-primary);
    font-size: 1rem;
    font-weight: 600;
}

.duration-input-group input:focus {
    outline: none;
    border-color: var(--accent-orange);
}

.duration-unit {
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-weight: 500;
    min-width: 60px;
}

.form-help {
    color: var(--text-secondary);
    font-size: 0.8rem;
    margin-top: 4px;
    display: block;
}

/* Estilos para modais (VERSÃO ROBUSTA) */
.modal-overlay {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background: rgba(0, 0, 0, 0.8) !important;
    
    /* MUDANÇA PRINCIPAL: Controle com visibility e opacity */
    display: flex !important; /* Deixe sempre flex para o alinhamento funcionar */
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s; /* Animação suave */

    align-items: center !important;
    justify-content: center !important;
    z-index: 99999 !important;
    padding: 20px !important;
}

.modal-overlay.modal-visible {
    /* MUDANÇA PRINCIPAL: Apenas mude a visibilidade e opacidade */
    visibility: visible;
    opacity: 1;
    transition-delay: 0s; /* Garante que a transição de entrada seja imediata */
}

.modal-content {
    background: var(--surface-color) !important;
    border-radius: 16px !important;
    padding: 24px !important;
    max-width: 400px !important;
    width: 100% !important;
    max-height: 90vh !important;
    overflow-y: auto !important;
    border: 1px solid var(--border-color) !important;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3) !important;
    position: relative !important;
    z-index: 100000 !important;
}

.modal-content h2 {
    margin: 0 0 20px 0;
    color: var(--text-primary);
    font-size: 1.3rem;
    text-align: center;
}

.modal-body {
    margin-bottom: 20px;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    color: var(--text-primary);
    font-weight: 600;
}

.form-input {
    width: 100%;
    padding: 12px 16px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background: var(--bg-color);
    color: var(--text-primary);
    font-size: 1rem;
}

.form-input:focus {
    outline: none;
    border-color: var(--accent-orange);
}

/* Input de horário customizado - LIMPO E SIMPLES */
.time-input {
    width: 100%;
    padding: 16px 20px;
    border-radius: 12px;
    border: 2px solid var(--border-color);
    background: var(--bg-color);
    color: var(--text-primary);
    font-size: 1.2rem;
    font-weight: 600;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    box-sizing: border-box;
    letter-spacing: 1px;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
}

.time-input:focus {
    outline: none;
    border-color: var(--accent-orange);
    box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
}

.modal-actions {
    display: flex;
    gap: 12px;
    justify-content: center;
}

.primary-button {
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
}

.primary-button.secondary-button {
    background: var(--surface-color);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.primary-button.secondary-button:hover {
    background: var(--border-color);
}

.primary-button:not(.secondary-button) {
    background: var(--accent-orange);
    color: white;
}

.primary-button:not(.secondary-button):hover {
    background: #e55a00;
}

/* Ajustes para mobile - inputs de horário */
@media (max-width: 480px) {
    .time-input {
        padding: 14px 16px;
        font-size: 1.1rem;
    }
}

/* Card de Consumo - Design Novo */
.card-consumption { 
    padding: 24px; 
    display: flex; 
    flex-direction: column; 
    gap: 20px; 
}

.card-consumption .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 10px;
    margin-bottom: 6px;
    border-bottom: 1px solid var(--glass-border);
}

.card-consumption .card-header h3 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--text-primary);
    font-weight: 700;
}

.card-consumption .view-all-link {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-decoration: none;
    transition: color 0.2s ease;
}

.card-consumption .view-all-link:hover {
    color: var(--accent-orange);
}

.card-consumption .consumption-content {
    display: flex;
    flex-direction: row; /* Sempre horizontal */
    gap: 16px;
    align-items: center;
    flex-wrap: nowrap; /* Nunca quebra em nova linha */
}

/* Círculo de Calorias (Lado Esquerdo) */
.consumption-calories {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
}

.consumption-calories-circle {
    position: relative;
    width: 110px;
    height: 110px;
    overflow: visible;
}

.consumption-calories-circle .circular-chart {
    display: block;
    width: 100%;
    height: 100%;
    transform: rotate(-90deg);
    overflow: visible;
}

.consumption-calories-circle .circle-bg {
    fill: none;
    stroke: rgba(255, 255, 255, 0.08);
    stroke-width: 3;
}

.consumption-calories-circle .circle {
    fill: none;
    stroke: url(#orange-gradient-consumption);
    stroke-width: 3;
    stroke-linecap: round;
    transition: stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    transform-origin: 50% 50%;
}

.consumption-calories-circle .circle-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.consumption-calories-circle .emoji {
    font-size: 1.5rem;
    line-height: 1;
}

.consumption-calories-circle .calories-value {
    font-size: 1.1rem;
    font-weight: 800;
    color: var(--text-primary);
    line-height: 1;
}

.consumption-calories-circle .calories-label {
    font-size: 0.65rem;
    color: var(--text-secondary);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}


/* Macros (Lado Direito) - Layout Grid */
.consumption-macros {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    align-items: center;
    max-width: 100%;
    min-width: 0; /* Permite encolher */
}

.consumption-macro-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    min-width: 0; /* Permite que o item encolha */
}

.consumption-macro-item .macro-emoji {
    font-size: 1.5rem;
    line-height: 1;
    margin-bottom: 2px;
}

.consumption-macro-item .macro-progress-bar {
    width: 100%;
    max-width: 30px; /* Largura bem reduzida */
    height: 5px; /* Aumentado de 4px para 5px */
    background: rgba(255, 255, 255, 0.08);
    border-radius: 2px;
    overflow: hidden;
    margin: 0 auto; /* Centraliza a barra */
}

.consumption-macro-item .macro-progress-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.6s ease;
}

.consumption-macro-item .macro-name {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-primary);
    text-transform: capitalize;
    text-align: center;
    margin-top: 2px;
}

.consumption-macro-item .macro-value {
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--text-primary);
    text-align: center;
}

.consumption-macro-item .macro-value .macro-goal {
    color: var(--text-secondary);
    font-weight: 400;
}

.consumption-macro-item.carbs .macro-progress-fill {
    background: linear-gradient(90deg, #4FC3F7, #29B6F6);
}

.consumption-macro-item.protein .macro-progress-fill {
    background: linear-gradient(90deg, #66BB6A, #43A047);
}

.consumption-macro-item.fat .macro-progress-fill {
    background: linear-gradient(90deg, #FFA726, #FB8C00);
}

/* Responsividade - Mantém layout horizontal, apenas reduz tamanhos */
@media (max-width: 480px) {
    .card-consumption .consumption-content {
        gap: 12px; /* Gap menor em mobile */
    }
    
    .consumption-calories-circle {
        width: 80px;
        height: 80px;
        flex-shrink: 0;
    }
    
    .consumption-calories-circle .emoji {
        font-size: 1.2rem;
    }
    
    .consumption-calories-circle .calories-value {
        font-size: 0.9rem;
    }
    
    .consumption-calories-circle .calories-label {
        font-size: 0.55rem;
    }
    
    
    .consumption-macros {
        gap: 8px; /* Gap menor entre macros */
    }
    
    .consumption-macro-item .macro-emoji {
        font-size: 1.2rem;
    }
    
    .consumption-macro-item .macro-name {
        font-size: 0.65rem;
    }
    
    .consumption-macro-item .macro-value {
        font-size: 0.7rem;
    }
    
    .consumption-macro-item .macro-progress-bar {
        max-width: 25px; /* Barra ainda menor em mobile */
        height: 4px; /* Aumentado de 3px para 4px */
    }
}

@media (max-width: 360px) {
    .card-consumption .consumption-content {
        gap: 8px;
    }
    
    .consumption-calories-circle {
        width: 70px;
        height: 70px;
    }
    
    .consumption-calories-circle .emoji {
        font-size: 1rem;
    }
    
    .consumption-calories-circle .calories-value {
        font-size: 0.8rem;
    }
    
    .consumption-calories-circle .calories-label {
        font-size: 0.5rem;
    }
    
    
    .consumption-macros {
        gap: 6px;
    }
    
    .consumption-macro-item .macro-progress-bar {
        max-width: 20px;
        height: 4px;
    }
}


/* ======================================================= */
/* --- CSS DAS MISSÕES --- */
/* ======================================================= */

.card-missions .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--glass-border);
}
.card-missions .view-all-link {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-decoration: none;
    transition: color 0.2s ease;
}
.card-missions .view-all-link:hover { color: var(--accent-orange); }

.missions-progress {display: flex;flex-direction: column;gap: 8px;}
.missions-progress-info {display: flex;justify-content: space-between;align-items: center;font-size: 0.9rem;color: var(--text-secondary);}
.missions-progress-info span:first-child {font-weight: 600;color: var(--text-primary);}
.progress-bar-missions {width: 100%;height: 6px;background-color: rgba(255, 255, 255, 0.1);border-radius: 3px;overflow: hidden;}
.progress-bar-missions-fill {height: 100%;border-radius: 3px;background-image: var(--primary-orange-gradient);transition: width 0.5s ease-in-out;}

.missions-carousel-container {
    position: relative;
    min-height: 180px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: visible;
}
.missions-carousel-container.has-completion {
    min-height: 100px;
    padding-top: 0;
    padding-bottom: 5px;
}
.mission-slide {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0;
    transform: scale(0.95);
    transition: opacity 0.4s ease, transform 0.4s ease;
    justify-content: space-between;
    padding: 10px 0;
}
.mission-slide.active {opacity: 1; transform: scale(1); z-index: 10;}
.mission-slide.completion-message {
    justify-content: center;
    padding-top: 10px;
    padding-bottom: 10px;
    align-items: center;
    top: 0;
}
.mission-slide.completion-message .mission-details {
    margin-bottom: 0;
}
.mission-icon i {
    background: var(--primary-orange-gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-size: 2.5rem;
}
.mission-details {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    width: 100%;
}
.mission-details h4 {font-size: 1.1rem; font-weight: 600;color: var(--text-primary);margin: 0 0 4px 0;}
.mission-details span {font-size: 0.9rem; font-weight: 500;color: #4CAF50;}
.mission-duration-display {
    font-size: 0.85rem;
    color: var(--text-secondary);
    font-weight: 500;
    margin-top: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all 0.3s ease;
}
.mission-actions {display: flex;gap: 20px;width: 100%;justify-content: center;}
.mission-action-btn {
    width: 55px;
    height: 55px;
    border-radius: 50%;
    border: none;
    font-size: 1.6rem;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}
.mission-action-btn.skip-btn {background-color: rgba(255, 255, 255, 0.1);color: var(--text-secondary);}
.mission-action-btn.skip-btn:hover {background-color: rgba(255, 255, 255, 0.15);}
.mission-action-btn.complete-btn {background-image: var(--primary-orange-gradient);color: var(--text-primary);}
.mission-action-btn.complete-btn:hover {filter: brightness(1.1);}
.mission-action-btn.duration-btn {background-color: rgba(255, 193, 7, 0.2);color: #ffc107;border: 1px solid rgba(255, 193, 7, 0.3);}
.mission-action-btn.duration-btn:hover {background-color: rgba(255, 193, 7, 0.3);}
.mission-action-btn.duration-btn:focus {outline: none;box-shadow: none;}
.mission-action-btn.complete-btn.disabled {opacity: 0.5;cursor: not-allowed;filter: none;}
.mission-action-btn.complete-btn.disabled:hover {filter: none;}
.mission-action-btn.complete-btn.disabled:focus {outline: none;box-shadow: none;}
.completion-message .mission-icon {
    margin-top: 8px;
    margin-bottom: 10px;
    padding-top: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}
.completion-message .mission-icon i { 
    font-size: 2.4rem; 
    margin-bottom: 0;
    display: block;
    line-height: 1;
    background: none !important;
    -webkit-background-clip: unset !important;
    -webkit-text-fill-color: var(--accent-orange) !important;
    color: var(--accent-orange) !important;
}
.completion-message .mission-details {
    margin-bottom: 8px;
}
.completion-message h4 { 
    font-size: 1.1rem; 
    margin-top: 0;
    margin-bottom: 4px;
}
.completion-message p {
    font-size: 0.9rem;
    margin: 0;
}

/* CSS CARROSSEL DE SUGESTÕES */
.suggestions-carousel {padding: 0 24px;scroll-padding: 0 24px;}
.suggestions-carousel .suggestion-item:last-child {margin-right: 24px;}
.card-suggestions .card-header {padding: 0 24px;}

/* ======================================= */
/* --- CSS DO CARD DE DESAFIOS --- */
/* ======================================= */
.card-challenges {
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.card-challenges .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 12px;
    border-bottom: 1px solid var(--glass-border);
}

.card-challenges .card-header h3 {
    margin: 0;
    font-size: 1.1rem;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 8px;
}

.card-challenges .card-header h3 i {
    color: var(--accent-orange);
}

.challenges-empty-state {
    text-align: center;
    padding: 40px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}

.challenges-empty-state .empty-state-icon {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: rgba(255, 107, 0, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 8px auto; /* Centralizado horizontalmente */
    position: relative; /* Para centralização perfeita do ícone */
}

.challenges-empty-state .empty-state-icon i {
    font-size: 2.5rem;
    color: var(--accent-orange);
    position: absolute; /* Centralização perfeita */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    line-height: 1; /* Remove espaçamento extra */
}

.challenges-empty-state h4 {
    margin: 0;
    font-size: 1.2rem;
    color: var(--text-primary);
    font-weight: 600;
}

.challenges-empty-state p {
    margin: 0 auto;
    font-size: 0.95rem;
    color: var(--text-secondary);
    line-height: 1.6;
    max-width: 400px;
    text-align: center;
}

.challenges-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.challenge-item {
    padding: 16px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.03);
    text-decoration: none;
    color: var(--text-primary);
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.challenge-item:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: var(--accent-orange);
    transform: translateY(-2px);
}

.challenge-item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 12px;
}

.challenge-item-header h4 {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    flex: 1;
}

.challenge-status {
    font-size: 0.85rem;
    font-weight: 600;
    padding: 4px 10px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.05);
    white-space: nowrap;
}

.challenge-description {
    margin: 0;
    font-size: 0.9rem;
    color: var(--text-secondary);
    line-height: 1.5;
}

.challenge-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.challenge-meta span {
    display: flex;
    align-items: center;
    gap: 6px;
}

.challenge-meta i {
    color: var(--accent-orange);
    font-size: 0.9rem;
}

.challenge-progress {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.challenge-progress-info {
    display: flex;
    justify-content: space-between;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.progress-bar-challenge {
    width: 100%;
    height: 6px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
}

.progress-bar-challenge-fill {
    height: 100%;
    border-radius: 3px;
    background-image: var(--primary-orange-gradient);
    transition: width 0.5s ease-in-out;
}

.challenge-goals-preview {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 4px;
}

.challenge-goal-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    border-radius: 16px;
    background: rgba(255, 107, 0, 0.1);
    border: 1px solid rgba(255, 107, 0, 0.2);
    font-size: 0.8rem;
    color: var(--text-primary);
    font-weight: 500;
}

.challenge-goal-badge i {
    color: var(--accent-orange);
    font-size: 0.85rem;
}

/* ======================================= */
/* --- CSS DO CARD DE RANKING --- */
/* ======================================= */
.card-ranking {
    grid-column: 1 / -1;
    padding: 15px;
}

.ranking-link {
    display: flex;
    align-items: center;
    justify-content: space-between;
    text-decoration: none;
    color: var(--text-primary);
}

.player-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    width: 60px;
    text-align: center;
}

.player-info .player-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background-color: var(--surface-color);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.player-info .player-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.player-info .player-avatar i {
    color: var(--accent-orange);
    font-size: 1.5rem;
}

.player-info span {
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
}

.clash-center {
    flex-grow: 1;
    text-align: center;
    padding: 0 15px;
}

.clash-title {
    font-size: 14px;
    color: var(--text-secondary);
    margin-bottom: 8px;
    display: block;
}

.clash-title.winner {
    color: #FFAE00;
    font-weight: 600;
}

.rank-position {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 8px;
    display: block;
}

.progress-bar {
    width: 100%;
    height: 6px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
    margin: 8px 0;
}

.progress-bar-fill {
    height: 100%;
    border-radius: 3px;
    background-image: var(--primary-orange-gradient);
    transition: width 0.5s ease-in-out;
}
.points-popup {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-primary);
    padding: 16px 24px;
    border-radius: 16px;
    font-size: 1rem;
    font-weight: 600;
    z-index: 2000;
    opacity: 0;
    animation: pointsPopupAnimation 2.5s ease-in-out forwards;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    display: flex;
    align-items: center;
    gap: 12px;
}

.points-popup .star-icon {
    font-size: 1.2rem;
    color: var(--accent-orange);
    animation: starPulse 1s ease-in-out infinite;
}

@keyframes pointsPopupAnimation {
    0% { 
        opacity: 0; 
        transform: translate(-50%, 20px); 
    } 
    20% { 
        opacity: 1; 
        transform: translate(-50%, 0); 
    }
    80% { 
        opacity: 1; 
        transform: translate(-50%, 0); 
    } 
    100% { 
        opacity: 0; 
        transform: translate(-50%, -20px); 
    }
}

/* Popup de Congratulação do Check-in */
.checkin-congrats-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30, 30, 30, 0.95);
    backdrop-filter: blur(30px);
    -webkit-backdrop-filter: blur(30px);
    border: 1px solid rgba(255, 107, 0, 0.3);
    color: var(--text-primary);
    padding: 2rem 2.5rem;
    border-radius: 20px;
    font-size: 1rem;
    font-weight: 600;
    z-index: 999999 !important;
    opacity: 0;
    animation: congratsPopupAnimation 3.5s ease-in-out forwards;
    pointer-events: auto;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 107, 0, 0.1);
    text-align: center;
    min-width: 300px;
    max-width: 90%;
}

.checkin-congrats-popup .congrats-icon {
    font-size: 2.5rem;
    margin-bottom: 1rem;
    color: var(--accent-orange);
    animation: congratsIconPulse 1.5s ease-in-out infinite;
    display: block;
}

.checkin-congrats-popup .congrats-message {
    font-size: 1.25rem;
    margin-bottom: 0.75rem;
    font-weight: 700;
    color: var(--text-primary);
}

.checkin-congrats-popup .congrats-subtitle {
    font-size: 0.95rem;
    color: var(--text-secondary);
    margin-bottom: 1.25rem;
    font-weight: 400;
}

.checkin-congrats-popup .congrats-points {
    font-size: 1.5rem;
    margin-top: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    color: var(--accent-orange);
    font-weight: 700;
}

.checkin-congrats-popup .congrats-points .star-icon {
    font-size: 1.25rem;
    color: var(--accent-orange);
    animation: starPulse 1s ease-in-out infinite;
}

@keyframes congratsPopupAnimation {
    0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.85); 
    } 
    10% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.02); 
    }
    20% { 
        transform: translate(-50%, -50%) scale(1); 
    }
    80% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
    } 
    100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.95); 
    }
}

@keyframes congratsIconPulse {
    0%, 100% { 
        transform: scale(1); 
    } 
    50% { 
        transform: scale(1.15); 
    }
}

@keyframes starPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

@keyframes fadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}

/* CSS simples: apenas esconder completados */
.mission-slide[data-completed="1"] {
    display: none !important;
}

/* Animação da estrela voando para o badge - Estilo Videogame */
.flying-star {
    position: fixed;
    z-index: 999998 !important;
    pointer-events: none;
    font-size: 1.5rem;
    color: var(--accent-orange);
    opacity: 1;
    transition: none;
    will-change: transform, opacity;
    filter: drop-shadow(0 0 8px rgba(255, 107, 0, 0.8));
    left: 0;
    top: 0;
    transform-origin: center center;
}

.flying-star.animate {
    /* A animação será controlada via JavaScript com requestAnimationFrame */
    /* CSS apenas para estilo base */
}

/* Animação de pulso no badge quando recebe pontos */
.points-counter-badge.points-updated {
    animation: badgePulse 1.2s ease-out;
}

@keyframes badgePulse {
    0% {
        transform: scale(1);
        border-color: var(--border-color);
    }
    20% {
        transform: scale(1.15);
        border-color: var(--accent-orange);
        box-shadow: 0 0 25px rgba(255, 107, 0, 0.5);
    }
    40% {
        transform: scale(1.1);
        border-color: var(--accent-orange);
        box-shadow: 0 0 30px rgba(255, 107, 0, 0.6);
    }
    60% {
        transform: scale(1.05);
        border-color: var(--accent-orange);
        box-shadow: 0 0 20px rgba(255, 107, 0, 0.4);
    }
    100% {
        transform: scale(1);
        border-color: var(--border-color);
    }
}

/* Animação de contagem dos pontos */
.points-counter-badge span.points-counting {
    animation: pointsCount 1.5s ease-out;
    color: var(--accent-orange);
    font-weight: 700;
}

@keyframes pointsCount {
    0% {
        transform: scale(1);
    }
    30% {
        transform: scale(1.4);
    }
    60% {
        transform: scale(1.2);
    }
    100% {
        transform: scale(1);
    }
}

/* Modal de Sono */

/* Botão de sono - IDÊNTICO ao duration-btn */
.mission-action-btn.sleep-btn {
    background-color: rgba(255, 193, 7, 0.2);
    color: #ffc107;
    border: 1px solid rgba(255, 193, 7, 0.3);
}

.mission-action-btn.sleep-btn:hover {
    background-color: rgba(255, 193, 7, 0.3);
}

.mission-action-btn.sleep-btn:focus {
    outline: none;
    box-shadow: none;
}
</style>

    </style>
</head>
<body>
    <div class="fixed-background"></div>
    <div id="alert-container"></div>
    
    <div class="app-container" id="dashboard-container" style="display: none;">
        <header class="header">
    <script src="./www-config.js"></script>
            <div class="header-actions">
                <a href="./points_history.html" class="points-counter-badge"><i class="fas fa-star"></i><span id="user-points-display">0</span></a>
                <a href="./edit_profile.html" class="profile-icon" id="profile-icon-link">
                    <i class="fas fa-user"></i>
                </a>
            </div>
        </header>

    <section class="main-carousel">
        <!-- Trilho móvel que contém todos os slides -->
        <div class="carousel-track">
            <div class="lottie-slide" data-link="./explore_recipes.html">
                <div class="lottie-animation-container"></div>
            </div>
            <div class="lottie-slide" data-link="#">
                <div class="lottie-animation-container"></div>
            </div>
            <div class="lottie-slide" data-link="./routine.html">
                <div class="lottie-animation-container"></div>
            </div>
            <div class="lottie-slide" data-link="./progress.html">
                <div class="lottie-animation-container"></div>
            </div>
        </div>
        
        <div class="pagination-container"></div>
</section>


    <section class="dashboard-grid">
        <div class="glass-card card-ranking" id="ranking-card" style="display: none;"><a href="./ranking.html" class="ranking-link">
            <div class="player-info left">
                <div class="player-avatar" id="user-avatar">
                    <i class="fas fa-user"></i>
                </div>
                <span>Você</span>
            </div>
            <div class="clash-center">
                <span class="clash-title" id="clash-title">Disputa de Pontos</span>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="ranking-progress-bar" style="width: 0%;"></div>
                </div>
                <span class="rank-position">Sua Posição: <strong id="my-rank">-</strong></span>
            </div>
            <div class="player-info right" id="opponent-info">
                <div class="player-avatar">
                    <i class="fas fa-user"></i>
                </div>
                <span id="opponent-name">-</span>
            </div>
        </a></div>
        
        <div class="glass-card card-weight" id="weight-card">
            <span>Carregando...</span>
        </div>

        <div class="glass-card card-hydration" id="water-card">
            <div class="hydration-content">
                <div class="hydration-info">
                    <h3>Hidratação</h3>
                    <div class="water-status" id="water-status-display">
                        <span id="water-amount-display">0</span> / <span id="water-goal-display">0 ml</span>
                    </div>
                    <div class="water-controls">
                        <div class="water-input-row">
                            <button type="button" id="water-remove-btn" class="circle-btn" aria-label="Remover">−</button>
                            <button type="button" id="water-add-btn" class="circle-btn accent" aria-label="Adicionar">+</button>
                        </div>
                        <div class="inline-input-row">
                            <input type="number" id="water-amount-input" class="water-number-input" min="0" step="10" value="" placeholder="EX: 250" aria-label="Quantidade consumida">
                            <div class="water-select-wrapper">
                                <select id="water-unit-select" class="water-select" aria-label="Unidade">
                                    <option value="ml" selected>ML</option>
                                    <option value="l">L</option>
                                </select>
                                <i class="fas fa-chevron-down water-select-arrow"></i>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <div class="water-drop-container-svg">
                    <svg id="animated-water-drop" width="160" height="160" viewBox="0 0 275.785 275.785" xml:space="preserve">
                        <defs>
                            <clipPath id="drop-mask">
                                <!-- CORREÇÃO: Usando o mesmo caminho do contorno para o clipPath para evitar vazamentos -->
                                <path d="M137.893,9.223 c14.177,18.895,91.267,123.692,91.267,169.701c0,50.31-40.952,91.255-91.267,91.255c-50.324,0-91.268-40.945-91.268-91.255 C46.625,132.915,123.712,28.118,137.893,9.223z"/>
                            </clipPath>
                            <linearGradient id="water-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stop-color="#4fc3f7" />
                                <stop offset="80%" stop-color="#1976d2" />
                            </linearGradient>
                            <!-- RESTAURADO: Filtro de glow para a água -->
                            <filter id="water-glow" x="-30%" y="-30%" width="160%" height="160%">
                                <feGaussianBlur stdDeviation="4" result="blur" />
                                <feComposite in="SourceGraphic" in2="blur" operator="over" />
                            </filter>
                        </defs>
                        <g clip-path="url(#drop-mask)">
                            <!-- RESTAURADO: Grupo com filtro de glow e que será movido pelo JS -->
                            <g id="water-level-group" transform="translate(0, 275.785)" filter="url(#water-glow)">
                                <!-- RESTAURADO: Ondas animadas em vez de um retângulo estático -->
                                <path id="wave1" d="M -400 10 C -300 15, -300 5, -200 10 C -100 15, -100 5, 0 10 C 100 15, 100 5, 200 10 C 300 15, 300 5, 400 10 L 400 280 H -400 Z" fill="url(#water-gradient)" opacity="0.9"/>
                                <path id="wave2" d="M -400 5 C -300 10, -300 0, -200 5 C -100 10, -100 0, 0 5 C 100 10, 100 0, 200 5 C 300 10, 300 0, 400 5 L 400 280 H -400 Z" fill="url(#water-gradient)" opacity="0.7"/>
                            </g>
                        </g>
                        <!-- Contorno da gota -->
                        <path d="M137.893,9.223 c14.177,18.895,91.267,123.692,91.267,169.701c0,50.31-40.952,91.255-91.267,91.255c-50.324,0-91.268-40.945-91.268-91.255 C46.625,132.915,123.712,28.118,137.893,9.223z" stroke="rgba(255, 255, 255, 0.4)" stroke-width="8" fill="none"/>
                    </svg>
                </div>
            </div>
        </div>
        
        <div class="glass-card card-consumption">
            <div class="card-header">
                <h3>Seu Consumo Hoje</h3>
                <a href="./dashboard.html" class="view-all-link">Minha Meta</a>
            </div>
            <div class="consumption-content">
                <!-- Círculo de Calorias (Esquerda) -->
                <div class="consumption-calories">
                    <div class="consumption-calories-circle" id="kcal-circle">
                        <svg viewBox="0 0 40 40" class="circular-chart" preserveAspectRatio="xMidYMid meet" style="overflow: visible;">
                            <defs>
                                <linearGradient id="orange-gradient-consumption" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stop-color="#FFAE00" />
                                    <stop offset="100%" stop-color="#F83600" />
                                </linearGradient>
                            </defs>
                            <circle class="circle-bg" cx="20" cy="20" r="15.9155" />
                            <circle class="circle" cx="20" cy="20" r="15.9155" stroke="url(#orange-gradient-consumption)" />
                        </svg>
                        <div class="circle-content">
                            <div class="emoji">🔥</div>
                            <div class="calories-value" id="kcal-value-display">0</div>
                            <div class="calories-label">kcal</div>
                        </div>
                    </div>
                </div>
                
                <!-- Macros (Direita) - Layout Horizontal -->
                <div class="consumption-macros">
                    <!-- Carboidratos -->
                    <div class="consumption-macro-item carbs">
                        <div class="macro-emoji">🍞</div>
                        <div class="macro-progress-bar">
                            <div class="macro-progress-fill" id="carbs-progress-bar" style="width: 0%"></div>
                        </div>
                        <div class="macro-name">Carbo</div>
                        <div class="macro-value">
                            <span id="carbs-value-display">0</span>g / <span class="macro-goal"><span id="carbs-goal-display">0</span>g</span>
                        </div>
                    </div>
                    
                    <!-- Proteínas -->
                    <div class="consumption-macro-item protein">
                        <div class="macro-emoji">🥩</div>
                        <div class="macro-progress-bar">
                            <div class="macro-progress-fill" id="protein-progress-bar" style="width: 0%"></div>
                        </div>
                        <div class="macro-name">Proteína</div>
                        <div class="macro-value">
                            <span id="protein-value-display">0</span>g / <span class="macro-goal"><span id="protein-goal-display">0</span>g</span>
                        </div>
                    </div>
                    
                    <!-- Gorduras -->
                    <div class="consumption-macro-item fat">
                        <div class="macro-emoji">🧈</div>
                        <div class="macro-progress-bar">
                            <div class="macro-progress-fill" id="fat-progress-bar" style="width: 0%"></div>
                        </div>
                        <div class="macro-name">Gordura</div>
                        <div class="macro-value">
                            <span id="fat-value-display">0</span>g / <span class="macro-goal"><span id="fat-goal-display">0</span>g</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="glass-card card-missions" id="missions-card" style="display: none;">
            <div class="card-header">
                <h3>Jornada Diária</h3>
                <a href="./routine.html" class="view-all-link">Ver mais</a>
            </div>
            <div class="missions-progress">
                <div class="missions-progress-info">
                    <span>Progresso</span>
                    <span id="missions-progress-text">0 de 0</span>
                </div>
                <div class="progress-bar-missions"><div class="progress-bar-missions-fill" id="missions-progress-bar" style="width: 0%;"></div></div>
            </div>
            
            <div class="missions-carousel-container" id="missions-carousel">
                <!-- Missões serão renderizadas via JavaScript -->
            </div>
        </div>
        
        <!-- Modal de Sono (inicialmente oculto) -->
        <div class="modal-overlay" id="sleep-modal-main">
            <div class="modal-content glass-card">
                <h2>😴 Registrar Sono</h2>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="sleep-time-main">Hora que deitou:</label>
                        <input type="time" id="sleep-time-main" class="time-input" value="22:00">
                    </div>
                    <div class="form-group">
                        <label for="wake-time-main">Hora que acordou:</label>
                        <input type="time" id="wake-time-main" class="time-input" value="07:00">
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="primary-button secondary-button" data-action="close-modal">Cancelar</button>
                    <button type="button" class="primary-button" id="confirm-sleep-main">Registrar Sono</button>
                </div>
            </div>
        </div>
        
        <div class="glass-card card-meal-cta" id="meal-cta-card">
            <i class="fas fa-utensils"></i>
            <h2>Carregando...</h2>
            <p>O que você vai comer agora?</p>
            <a href="#" class="primary-button" id="add-meal-btn">Adicionar Refeição</a>
        </div>
        
        <div class="card-suggestions" id="suggestions-card" style="display: none;">
            <div class="card-header">
                <h3 id="suggestions-title">Sugestões</h3>
                <a href="#" class="view-all-link" id="suggestions-view-all">Ver mais</a>
            </div>
            <div class="carousel-wrapper">
                <div class="suggestions-carousel" id="suggestions-carousel">
                    <!-- Receitas serão renderizadas via JavaScript -->
                </div>
            </div>
        </div>
        
        <!-- Card de Grupos de Desafio -->
        <div class="glass-card card-challenges" id="challenges-card" style="display: none;">
            <div class="card-header">
                <h3><i class="fas fa-trophy"></i> Grupos de Desafio</h3>
                <a href="./challenges.html" class="view-all-link" id="challenges-view-all" style="display: none;">Ver todos</a>
            </div>
            
            <div class="challenges-empty-state" id="challenges-empty-state" style="display: none;">
                <div class="empty-state-icon">
                    <i class="fas fa-trophy"></i>
                </div>
                <h4>Nenhum grupo de desafio</h4>
                <p>Você não foi adicionado(a) em nenhum grupo de desafios. Consulte seu nutricionista para mais informações.</p>
            </div>
            
            <div class="challenges-list" id="challenges-list">
                <!-- Desafios serão renderizados via JavaScript -->
            </div>
        </div>
        
    </section>
</div>

<div class="modal-overlay" id="edit-weight-modal">
    <div class="modal-content glass-card">
        <h2>Atualizar seu Peso</h2>
        <div class="modal-body">
            <div class="form-group">
                <label for="new-weight-input">Novo peso (kg)</label>
                <input type="number" id="new-weight-input" class="form-input" placeholder="Ex: 75.5" step="0.1" value="">
                <small id="weight-error-message" class="error-message" style="display: none;"></small>
            </div>
            <div class="modal-actions">
                <button type="button" class="primary-button secondary-button" data-action="close-modal">Cancelar</button>
                <button id="save-weight-btn" class="primary-button">Salvar</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal para duração de exercício -->
<div class="modal-overlay" id="exercise-duration-modal">
    <div class="modal-content glass-card">
        <h2>⏱️ Duração do Exercício</h2>
        <div class="modal-body">
            <div class="form-group">
                <label for="exercise-duration-input">Quanto tempo durou o exercício?</label>
                <div class="duration-input-group">
                    <input type="number" id="exercise-duration-input" class="form-input" placeholder="Ex: 45" min="15" max="300" value="60">
                    <span class="duration-unit">minutos</span>
                </div>
                <small class="form-help">Entre 15 e 300 minutos</small>
            </div>
            <div class="modal-actions">
                <button type="button" class="primary-button secondary-button" data-action="close-modal">Cancelar</button>
                <button type="button" class="primary-button" id="confirm-exercise-duration">Confirmar</button>
            </div>
        </div>
    </div>
</div>

<script>
    if (window.navigator.standalone === true) {document.addEventListener('click', function(event) {var target = event.target; while (target && target.nodeName !== 'A') { target = target.parentNode; } if (target && target.nodeName === 'A' && target.target !== '_blank') {event.preventDefault(); window.location.href = target.href;}}, false);}

    function showPointsPopup(message) {
        const popup = document.createElement('div');
        popup.className = 'points-popup';
        popup.innerHTML = `<i class="fas fa-star star-icon"></i>${message}`;
        document.body.appendChild(popup);
        setTimeout(() => { popup.remove(); }, 2500);
    }
    
    // Função para animar contagem de pontos de forma fluida
    function animatePointsCount(element, startValue, endValue, duration) {
        const startTime = performance.now();
        const formatNumber = (num) => new Intl.NumberFormat('pt-BR').format(num);
        
        // Usar easing mais suave (ease-in-out cubic)
        function easeInOutCubic(t) {
            return t < 0.5 
                ? 4 * t * t * t 
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function update(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Easing mais fluido
            const easedProgress = easeInOutCubic(progress);
            
            const currentValue = Math.floor(startValue + (endValue - startValue) * easedProgress);
            element.textContent = formatNumber(currentValue);
            
            if (progress < 1) {
                requestAnimationFrame(update);
            } else {
                // Garantir valor final exato
                element.textContent = formatNumber(endValue);
            }
        }
        
        requestAnimationFrame(update);
    }
    
    // Função genérica para animar estrela voando de qualquer elemento para o badge
    // Animação tipo videogame com trajetória perfeita usando requestAnimationFrame
    function animateStarToBadgeFromElement(sourceElement, points, newTotalPoints) {
        const pointsBadge = document.querySelector('.points-counter-badge');
        const pointsDisplay = document.getElementById('user-points-display');
        
        if (!sourceElement || !pointsBadge || !pointsDisplay || points <= 0) {
            // Se não tem pontos ou elementos não existem, apenas atualizar normalmente
            if (newTotalPoints !== undefined && pointsDisplay) {
                pointsDisplay.textContent = new Intl.NumberFormat('pt-BR').format(newTotalPoints);
            }
            return;
        }
        
        // Obter posições EXATAS
        const sourceRect = sourceElement.getBoundingClientRect();
        const badgeRect = pointsBadge.getBoundingClientRect();
        
        // Encontrar o ícone da estrela DENTRO do badge (não apenas o centro)
        const starIcon = pointsBadge.querySelector('i.fa-star');
        let endX, endY;
        
        if (starIcon) {
            // Se encontrou o ícone, usar sua posição exata
            const starRect = starIcon.getBoundingClientRect();
            endX = starRect.left + starRect.width / 2;
            endY = starRect.top + starRect.height / 2;
        } else {
            // Fallback: centro do badge
            endX = badgeRect.left + badgeRect.width / 2;
            endY = badgeRect.top + badgeRect.height / 2;
        }
        
        // Posição inicial (centro do elemento fonte)
        const startX = sourceRect.left + sourceRect.width / 2;
        const startY = sourceRect.top + sourceRect.height / 2;
        
        // Calcular distância total
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Duração baseada na distância (mais rápido para distâncias curtas, mais lento para longas)
        // Mínimo 1.2s, máximo 2.5s
        const baseDuration = 1800; // 1.8 segundos base
        const duration = Math.min(Math.max(baseDuration, distance * 0.8), 2500);
        
        // Obter valor atual dos pontos
        const currentPointsText = pointsDisplay.textContent.replace(/\./g, '').replace(/,/g, '');
        const currentPoints = parseInt(currentPointsText) || 0;
        
        // Criar estrela voadora
        const flyingStar = document.createElement('div');
        flyingStar.className = 'flying-star';
        flyingStar.innerHTML = '<i class="fas fa-star"></i>';
        // Posicionar inicialmente usando left/top para garantir que fique na posição correta
        flyingStar.style.left = `${startX}px`;
        flyingStar.style.top = `${startY}px`;
        flyingStar.style.transform = 'translate(-50%, -50%) scale(1) rotate(0deg)';
        flyingStar.style.willChange = 'transform, opacity';
        
        document.body.appendChild(flyingStar);
        
        // Forçar reflow
        flyingStar.offsetHeight;
        
        // Função de easing tipo videogame (ease-out com bounce sutil no final)
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }
        
        // Função de easing com ligeiro "bounce" no final (tipo videogame)
        function easeOutBack(t) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        }
        
        // Animação com requestAnimationFrame para controle preciso
        // RECALCULA POSIÇÕES EM TEMPO REAL para acompanhar scroll
        const startTime = performance.now();
        let animationFrameId;
        
        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // RECALCULAR posição final do badge EM TEMPO REAL (para acompanhar scroll)
            let currentEndX, currentEndY;
            const currentBadgeRect = pointsBadge.getBoundingClientRect();
            const currentBadgeStarIcon = pointsBadge.querySelector('i.fa-star');
            
            if (currentBadgeStarIcon) {
                const currentBadgeStarRect = currentBadgeStarIcon.getBoundingClientRect();
                currentEndX = currentBadgeStarRect.left + currentBadgeStarRect.width / 2;
                currentEndY = currentBadgeStarRect.top + currentBadgeStarRect.height / 2;
            } else {
                currentEndX = currentBadgeRect.left + currentBadgeRect.width / 2;
                currentEndY = currentBadgeRect.top + currentBadgeRect.height / 2;
            }
            
            // RECALCULAR posição inicial também (caso elemento fonte tenha se movido)
            const currentSourceRect = sourceElement.getBoundingClientRect();
            const currentStartX = currentSourceRect.left + currentSourceRect.width / 2;
            const currentStartY = currentSourceRect.top + currentSourceRect.height / 2;
            
            // Calcular delta atualizado
            const currentDeltaX = currentEndX - currentStartX;
            const currentDeltaY = currentEndY - currentStartY;
            const currentDistance = Math.sqrt(currentDeltaX * currentDeltaX + currentDeltaY * currentDeltaY);
            
            // Usar easing suave (ease-out cubic) para movimento natural
            const easedProgress = easeOutCubic(progress);
            
            // Calcular posição atual baseada nas posições RECALCULADAS
            const currentX = currentStartX + (currentDeltaX * easedProgress);
            const currentY = currentStartY + (currentDeltaY * easedProgress);
            
            // Adicionar curva suave (parábola leve) para trajetória mais natural
            const curveHeight = Math.min(currentDistance * 0.12, 80); // Reduzido para curva mais suave
            const curveProgress = Math.sin(progress * Math.PI); // Curva em formato de onda
            const curveOffset = -curveHeight * curveProgress; // Offset vertical para curva
            
            // ESCALA SUAVIZADA - evitar mudanças bruscas
            let scale;
            // Usar easing para suavizar transições de escala
            if (progress < 0.2) {
                // Início: escala aumenta suavemente
                const scaleProgress = progress / 0.2;
                scale = 1 + (0.3 * easeOutCubic(scaleProgress)); // Reduzido de 0.4 para 0.3
            } else if (progress < 0.75) {
                // Meio: escala diminui suavemente
                const scaleProgress = (progress - 0.2) / 0.55;
                const easedScaleProgress = easeOutCubic(scaleProgress);
                scale = 1.3 - (0.4 * easedScaleProgress); // Reduzido de 0.6 para 0.4
            } else {
                // Final: escala aumenta ligeiramente antes de desaparecer
                const finalProgress = (progress - 0.75) / 0.25;
                const easedFinalProgress = easeOutCubic(finalProgress);
                scale = 0.9 + (0.2 * easedFinalProgress); // Reduzido de 0.3 para 0.2
            }
            
            // Rotação dinâmica (gira durante o voo) - suavizada
            const rotation = progress * 360 * 1.5; // Reduzido de 2 para 1.5 rotações
            
            // Opacidade (fade out suave no final)
            let opacity = 1;
            if (progress > 0.9) {
                // Fade out apenas nos últimos 10%
                opacity = 1 - ((progress - 0.9) / 0.1);
            }
            
            // Usar left/top + transform para garantir que a estrela não saia da viewport
            flyingStar.style.left = `${currentX}px`;
            flyingStar.style.top = `${currentY + curveOffset}px`;
            flyingStar.style.transform = `translate(-50%, -50%) scale(${scale}) rotate(${rotation}deg)`;
            flyingStar.style.opacity = opacity;
            
            // Continuar animação ou finalizar
            if (progress < 1) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                // Animação completa
                if (flyingStar.parentNode) {
                    flyingStar.parentNode.removeChild(flyingStar);
                }
                
                // Atualizar pontos quando estrela chega
                const finalPoints = newTotalPoints !== undefined ? newTotalPoints : (currentPoints + points);
                
                // Adicionar classe de animação no badge
                pointsBadge.classList.add('points-updated');
                
                // Animar contagem dos pontos
                pointsDisplay.classList.add('points-counting');
                
                // Atualizar valor com animação de contagem
                animatePointsCount(pointsDisplay, currentPoints, finalPoints, 1500);
                
                // Remover classes de animação após animação
                setTimeout(() => {
                    pointsBadge.classList.remove('points-updated');
                    pointsDisplay.classList.remove('points-counting');
                }, 2000);
            }
        }
        
        // Iniciar animação
        animationFrameId = requestAnimationFrame(animate);
        
        // Limpar animação se elemento for removido
        flyingStar._animationId = animationFrameId;
    }
    
    // Função para mostrar popup de pontos e animar estrela voando
    function showPointsWithStarAnimation(message, sourceElement, points, newTotalPoints) {
        // Mostrar popup temporário
        const popup = document.createElement('div');
        popup.className = 'points-popup';
        popup.innerHTML = `<i class="fas fa-star star-icon" id="points-popup-star"></i>${message}`;
        document.body.appendChild(popup);
        
        // Após um pequeno delay, fazer estrela voar
        setTimeout(() => {
            const starIcon = document.getElementById('points-popup-star');
            if (starIcon) {
                animateStarToBadgeFromElement(starIcon, points, newTotalPoints);
            }
            // Remover popup após um tempo
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 1000);
        }, 500);
    }

    // Variáveis globais para missões
    let missionSlides = [];
    let completionCard = null;
    let completedMissionsCount = 0;
    let totalMissionsCount = 0;
    let pendingSlides = [];
    
    // Garantir que funções sejam globais para evitar problemas com SPA
    if (typeof window.showCurrentMission === 'undefined') {
        window.showCurrentMission = function() {
            // Lógica simples igual ao main_app.php
            if (typeof missionSlides !== 'undefined' && missionSlides) {
                missionSlides.forEach(s => s.classList.remove('active'));
            }
            if (completionCard) completionCard.classList.remove('active');
            
            if (pendingSlides.length > 0) {
                pendingSlides[0].classList.add('active');
            } else {
                if (completionCard) completionCard.classList.add('active');
            }
        };
    }
    
    if (typeof window.initializeMissionsCarousel === 'undefined') {
        window.initializeMissionsCarousel = function() {
            // --- LÓGICA DO CARROSSEL DE MISSÕES ---
        const missionsCarousel = document.getElementById('missions-carousel');
        if (!missionsCarousel) {
            // Tentar novamente depois de um delay se não encontrou
            setTimeout(initializeMissionsCarousel, 100);
            return;
        }
        
        // Remover event listeners antigos se existirem
        const newCarousel = missionsCarousel.cloneNode(true);
        missionsCarousel.parentNode.replaceChild(newCarousel, missionsCarousel);
        
        // Buscar elementos novamente
        const updatedCarousel = document.getElementById('missions-carousel');
        missionSlides = Array.from(updatedCarousel.querySelectorAll('.mission-slide:not(.completion-message)'));
        completionCard = document.getElementById('all-missions-completed-card');
        pendingSlides = missionSlides.filter(slide => slide.dataset.completed === '0');
        
        if (missionSlides.length > 0 || completionCard) {
            showCurrentMission();
        }
        
        // Event listener simples igual ao main_app.php
        updatedCarousel.addEventListener('click', function(event) {
            // Prevenir múltiplos cliques
            if (event.target.disabled || event.target.classList.contains('processing')) {
                return;
            }

            const completeButton = event.target.closest('.complete-btn');
            const skipButton = event.target.closest('.skip-btn');
            const durationButton = event.target.closest('.duration-btn');
            const sleepButton = event.target.closest('.sleep-btn');
            
            if (!completeButton && !skipButton && !durationButton && !sleepButton) return;
            
            const currentSlide = pendingSlides[0];
            if (!currentSlide) return;

            if (skipButton) {
                // Lógica simples: move para o final da fila
                pendingSlides.push(pendingSlides.shift());
                showCurrentMission();
            } else if (durationButton) {
                // Botão de duração clicado
                const missionId = durationButton.dataset.missionId;
                showExerciseDurationModal(missionId, currentSlide, durationButton);
            } else if (sleepButton) {
                // Botão de sono clicado - apenas abre o modal
                const modal = document.getElementById('sleep-modal-main');
                if (modal) {
                    modal.classList.add('modal-visible');
                    document.body.style.overflow = 'hidden';
                }
            } else if (completeButton) {
                // Prevenir múltiplos cliques
                if (completeButton.disabled || completeButton.classList.contains('processing')) {
                    return;
                }

                // Se o botão tem a classe .disabled, mostra o alerta e para.
                if (completeButton.classList.contains('disabled')) {
                    const missionId = currentSlide.dataset.missionId;
                    if (String(missionId).startsWith('onboarding_')) {
                        alert('⚠️ Para completar, primeiro defina a duração do exercício!');
                    } 
                    else if (currentSlide.querySelector('.sleep-btn')) {
                        alert('⚠️ Para completar, primeiro registre seus horários de sono!');
                    }
                    return; // Impede que a tarefa seja completada.
                }
                
                // Se não tiver a classe .disabled, completa a tarefa.
                if (currentSlide.dataset.completed === '1') return;

                const missionId = currentSlide.dataset.missionId;
                
                // Verificar se é uma atividade de exercício (onboarding_)
                if (String(missionId).startsWith('onboarding_')) {
                    // Exercício onboarding - só funciona se já tiver duração definida
                    const durationBtn = currentSlide.querySelector('.duration-btn');
                    if (durationBtn && durationBtn.dataset.durationSet === 'true') {
                        completeExerciseWithDuration(missionId, durationBtn.dataset.duration, currentSlide, completeButton);
                    } else {
                        // Se chegou aqui por algum motivo (pouco provável com a verificação acima), mostre o popup
                        showPointsPopup('⚠️ Defina a duração do exercício primeiro!');
                    }
                } else if (currentSlide.querySelector('.sleep-btn')) {
                    // Item de sono - completar diretamente (botão só fica habilitado após registrar)
                    completeSleepRoutine(missionId, completeButton);
                } else {
                    // Completar diretamente para outras atividades
                    completeRoutineDirectly(missionId, completeButton);
                }
            }
        });
        };
    }
    
    function updateMissionsProgress() {
        const progressPercentage = totalMissionsCount > 0 ? (completedMissionsCount / totalMissionsCount) * 100 : 0;
        const progressBarFill = document.getElementById('missions-progress-bar');
        const progressText = document.getElementById('missions-progress-text');
        if (progressBarFill) { progressBarFill.style.width = `${progressPercentage}%`; }
        if (progressText) { progressText.textContent = `${completedMissionsCount} de ${totalMissionsCount}`; }
        
        // Verificar se todas as missões foram completadas e mostrar card de conclusão
        if (completedMissionsCount === totalMissionsCount && totalMissionsCount > 0) {
            const missionsCarousel = document.getElementById('missions-carousel');
            if (missionsCarousel) {
                // Verificar se o card de conclusão já existe
                let completionCard = document.getElementById('all-missions-completed-card');
                if (!completionCard) {
                    // Adicionar card de conclusão
                    const completionHTML = `
                        <div class="mission-slide completion-message active" id="all-missions-completed-card">
                            <div class="mission-details"><h4>Parabéns!</h4><p>Você completou sua jornada de hoje.</p></div>
                        </div>
                    `;
                    missionsCarousel.insertAdjacentHTML('beforeend', completionHTML);
                    completionCard = document.getElementById('all-missions-completed-card');
                    
                    // Adicionar classe ao container para aumentar altura
                    missionsCarousel.classList.add('has-completion');
                }
                
                // Atualizar slides e mostrar card de conclusão
                missionSlides = Array.from(missionsCarousel.querySelectorAll('.mission-slide:not(.completion-message)'));
                pendingSlides = missionSlides.filter(slide => slide.dataset.completed === '0');
                showCurrentMission();
            }
        }
    }
    
    // Função para mostrar modal de duração de exercício
    function showExerciseDurationModal(missionId, currentSlide, durationButton) {
                console.log('showExerciseDurationModal chamada!');
                const exerciseName = missionId.replace('onboarding_', '');
                const modal = document.getElementById('exercise-duration-modal');
                const durationInput = document.getElementById('exercise-duration-input');
                
                if (!modal) {
                    console.error('Modal não encontrado!');
                    return;
                }
                
                // Configurar o modal
                modal.querySelector('h2').textContent = `⏱️ Duração - ${exerciseName}`;
                
                // NOVO: Pré-preenche o valor se já foi definido (funcionalidade de edição)
                if (durationButton.dataset.durationSet === 'true') {
                    durationInput.value = durationButton.dataset.duration;
                } else {
                    durationInput.value = 60; // Valor padrão para a primeira vez
                }
                
                modal.classList.add('modal-visible');
                console.log('Modal deve estar visível agora!');
                
                const cancelBtn = modal.querySelector('[data-action="close-modal"]');
                if (cancelBtn) {
                    cancelBtn.onclick = () => {
                        modal.classList.remove('modal-visible');
                    };
                }
                
                document.getElementById('confirm-exercise-duration').onclick = () => {
                    const duration = parseInt(durationInput.value);
                    if (duration >= 15 && duration <= 300) {
                        modal.classList.remove('modal-visible');

                        // Salva a duração no botão para referência futura
                        durationButton.dataset.durationSet = 'true';
                        durationButton.dataset.duration = duration;

                        // NOVO: Garante que o botão de duração (agora edição) esteja visível
                        durationButton.style.display = 'flex'; 
                        
                        // Habilita o botão de completar original
                        const completeBtn = currentSlide.querySelector('.complete-btn.disabled');
                        if (completeBtn) {
                            completeBtn.disabled = false;
                            completeBtn.classList.remove('disabled');
                        }

                        // NOVO: Mostra o texto da duração no card
                        const durationDisplay = currentSlide.querySelector('.mission-duration-display');
                        if (durationDisplay) {
                            durationDisplay.innerHTML = `<i class="fas fa-stopwatch" style="font-size: 0.8em;"></i> ${duration} min`;
                            durationDisplay.style.display = 'flex';
                        }
                        
                        console.log('Duração definida:', duration, 'minutos');
                    } else {
                        alert('Por favor, insira uma duração entre 15 e 300 minutos.');
                    }
                };
            }

    // Função para completar exercício com duração
    function completeExerciseWithDuration(missionId, duration, currentSlide, completeButton) {
                const routineIdToSend = missionId.replace('onboarding_', '');
                
                if (!duration || duration < 1) {
                    alert('Por favor, defina uma duração válida.');
                    return;
                }
                
                completeButton.disabled = true;
                completeButton.classList.add('processing');
                
                authenticatedFetch(`${window.BASE_APP_URL}/api/complete_exercise_with_duration.php`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        routine_id: routineIdToSend,
                        duration_minutes: parseInt(duration)
                    })
                })
                .then(async response => {
                    if (!response) {
                        throw new Error('Resposta vazia do servidor');
                    }
                    if (!response.ok) {
                        const text = await response.text();
                        console.error('Erro ao completar exercício:', text);
                        throw new Error(`Erro de Servidor (${response.status}): ${text.substring(0, 200)}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        currentSlide.dataset.completed = '1';
                        completedMissionsCount++;
                        updateMissionsProgress();
                        pendingSlides.shift();
                        
                        // Animar estrela voando se ganhou pontos
                        if (data.points_awarded > 0) {
                            const completeButton = currentSlide.querySelector('.complete-btn');
                            showPointsWithStarAnimation(
                                `+${data.points_awarded} Pontos`,
                                completeButton || currentSlide,
                                data.points_awarded,
                                data.new_total_points
                            );
                        } else if (data.new_total_points !== undefined) {
                            // Se não ganhou pontos mas tem novo total, atualizar normalmente
                            const pointsDisplay = document.getElementById('user-points-display');
                            if (pointsDisplay) {
                                pointsDisplay.textContent = new Intl.NumberFormat('pt-BR').format(data.new_total_points);
                            }
                        }
                        setTimeout(showCurrentMission, 300);
                    } else {
                        alert(data.message || 'Ocorreu um erro ao processar a solicitação.');
                        completeButton.disabled = false;
                        completeButton.classList.remove('processing');
                    }
                })
                .catch(error => {
                    console.error('Erro detalhado:', error);
                    alert('Falha na comunicação com o servidor. Verifique o console para mais detalhes.');
                    completeButton.disabled = false;
                    completeButton.classList.remove('processing');
                });
            }

    // Função para completar rotina de sono
    function completeSleepRoutine(missionId, completeButton) {
                const sleepData = JSON.parse(sessionStorage.getItem('sleep_data'));
                
                if (!sleepData || !sleepData.sleep_time || !sleepData.wake_time) {
                    alert('Por favor, registre os horários de sono primeiro.');
                    return;
                }
                
                completeButton.disabled = true;
                completeButton.classList.add('processing');
                
                authenticatedFetch(`${window.BASE_APP_URL}/api/complete_sleep_routine.php`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        routine_id: missionId,
                        sleep_time: sleepData.sleep_time,
                        wake_time: sleepData.wake_time
                    })
                })
                .then(async response => {
                    if (!response) {
                        throw new Error('Resposta vazia do servidor');
                    }
                    if (!response.ok) {
                        const text = await response.text();
                        console.error('Erro ao completar sono:', text);
                        throw new Error(`Erro de Servidor (${response.status}): ${text.substring(0, 200)}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Limpar dados do sessionStorage
                        sessionStorage.removeItem('sleep_data');
                        
                        // Atualizar o progresso das missões
                        const currentSlide = pendingSlides[0];
                        if (currentSlide) {
                            currentSlide.dataset.completed = '1';
                            completedMissionsCount++;
                            updateMissionsProgress();
                            pendingSlides.shift();
                            setTimeout(showCurrentMission, 300);
                        }
                        
                        // Animar estrela voando se ganhou pontos
                        if (data.points_awarded > 0) {
                            const completeButton = currentSlide.querySelector('.complete-btn');
                            showPointsWithStarAnimation(
                                `+${data.points_awarded} Pontos`,
                                completeButton || currentSlide,
                                data.points_awarded,
                                data.new_total_points
                            );
                        } else if (data.new_total_points !== undefined) {
                            // Se não ganhou pontos mas tem novo total, atualizar normalmente
                            const pointsDisplay = document.getElementById('user-points-display');
                            if (pointsDisplay) {
                                pointsDisplay.textContent = new Intl.NumberFormat('pt-BR').format(data.new_total_points);
                            }
                        }
                    } else {
                        alert('Erro: ' + (data.message || 'Falha ao registrar sono'));
                        completeButton.disabled = false;
                        completeButton.classList.remove('processing');
                    }
                })
                .catch(error => {
                    console.error('Erro:', error);
                    alert('Erro na comunicação com o servidor.');
                    completeButton.disabled = false;
                    completeButton.classList.remove('processing');
                });
            }

    // Função para completar rotinas normais (não exercícios)
    function completeRoutineDirectly(missionId, completeButton) {
                completeButton.disabled = true;
                completeButton.classList.add('processing');
                
                authenticatedFetch(`${window.BASE_APP_URL}/api/complete_routine_item.php`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        routine_id: missionId
                    })
                })
                .then(async response => {
                    if (!response) {
                        throw new Error('Resposta vazia do servidor');
                    }
                    if (!response.ok) {
                        const text = await response.text();
                        console.error('Erro ao completar rotina:', text);
                        throw new Error(`Erro de Servidor (${response.status}): ${text.substring(0, 200)}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        const currentSlide = pendingSlides[0];
                        if (currentSlide) {
                            currentSlide.dataset.completed = '1';
                            completedMissionsCount++;
                            updateMissionsProgress();
                            pendingSlides.shift();
                            
                            // Animar estrela voando se ganhou pontos
                            if (data.points_awarded > 0) {
                                const completeButton = currentSlide.querySelector('.complete-btn');
                                showPointsWithStarAnimation(
                                    `+${data.points_awarded} Pontos`,
                                    completeButton || currentSlide,
                                    data.points_awarded,
                                    data.new_total_points
                                );
                            } else if (data.new_total_points !== undefined) {
                                // Se não ganhou pontos mas tem novo total, atualizar normalmente
                                const pointsDisplay = document.getElementById('user-points-display');
                                if (pointsDisplay) {
                                    pointsDisplay.textContent = new Intl.NumberFormat('pt-BR').format(data.new_total_points);
                                }
                            }
                            setTimeout(showCurrentMission, 300);
                        }
                    } else {
                        alert(data.message || 'Ocorreu um erro ao processar a solicitação.');
                        completeButton.disabled = false;
                        completeButton.classList.remove('processing');
                    }
                })
                .catch(error => {
                    console.error('Erro detalhado:', error);
                    alert('Falha na comunicação com o servidor. Verifique o console para mais detalhes.');
                    completeButton.disabled = false;
                    completeButton.classList.remove('processing');
                });
            }
    
    document.addEventListener('DOMContentLoaded', function() {
        // Inicializar carrossel de missões (tentará novamente se não encontrar elementos)
        initializeMissionsCarousel();
        
        // Event listener para o botão de confirmar sono
        const confirmSleepBtn = document.getElementById('confirm-sleep-main');
        if (confirmSleepBtn) {
            confirmSleepBtn.addEventListener('click', function() {
                const modal = document.getElementById('sleep-modal-main');
                const sleepTime = modal.querySelector('#sleep-time-main').value;
                const wakeTime = modal.querySelector('#wake-time-main').value;

                if (!sleepTime || !wakeTime) {
                    alert('Por favor, preencha ambos os horários.');
                    return;
                }

                if (sleepTime === wakeTime) {
                    alert('Os horários de dormir e acordar não podem ser iguais.');
                    return;
                }

                // Salvar dados no sessionStorage
                const sleepData = {
                    sleep_time: sleepTime,
                    wake_time: wakeTime
                };
                sessionStorage.setItem('sleep_data', JSON.stringify(sleepData));

                // Fechar modal
                modal.classList.remove('modal-visible');
                document.body.style.overflow = '';

            // Habilitar o botão de completar (igual aos exercícios)
            const currentSlide = pendingSlides[0];
            if (currentSlide) {
                const completeBtn = currentSlide.querySelector('.complete-btn.disabled');
                if (completeBtn) {
                    completeBtn.classList.remove('disabled');
                }
                
                // Mostrar duração do sono (igual aos exercícios)
                const durationDisplay = currentSlide.querySelector('.mission-duration-display');
                if (durationDisplay) {
                    const sleepTime = new Date(`2000-01-01T${sleepData.sleep_time}`);
                    const wakeTime = new Date(`2000-01-01T${sleepData.wake_time}`);
                    
                    // Calcular diferença em horas
                    let diffMs = wakeTime - sleepTime;
                    if (diffMs < 0) {
                        // Se acordou no dia seguinte
                        diffMs += 24 * 60 * 60 * 1000;
                    }
                    const diffHours = Math.round(diffMs / (60 * 60 * 1000) * 10) / 10;
                    
                    durationDisplay.innerHTML = `<i class="fas fa-moon" style="font-size: 0.8em;"></i> ${diffHours}h de sono`;
                    durationDisplay.style.display = 'flex';
                }
            }
            });
        }

        // --- LÓGICA DO CARD DE HIDRATAÇÃO ---
        // Usar variáveis locais dentro de função para evitar re-declarações
        let waterLevelGroup = document.getElementById('water-level-group');
        let waterAmountDisplay = document.getElementById('water-amount-display');
		let waterAmountInput = document.getElementById('water-amount-input');
		let waterAddBtn = document.getElementById('water-add-btn');
		let waterUnitSelect = document.getElementById('water-unit-select');

        window.currentWater = window.currentWater || 0;
        const waterGoal = 2000;
        const CUP_SIZE_ML = 250;
        const dropHeight = 275.785; 

        function updateWaterDrop(animated = true) {
            // Verificar se elementos existem antes de acessar
            if (!waterLevelGroup || !waterAmountDisplay) {
                console.warn('[Water Drop] Elementos não encontrados, pulando atualização');
                return;
            }
            
            const percentage = waterGoal > 0 ? Math.min(window.currentWater / waterGoal, 1) : 0;
            const yTranslate = dropHeight * (1 - percentage);
            
            if (!animated) {
                waterLevelGroup.style.transition = 'none';
            }
            
            waterLevelGroup.setAttribute('transform', `translate(0, ${yTranslate})`);

            if (!animated) {
                // Força o navegador a aplicar o estilo sem transição imediatamente
                setTimeout(() => {
                    waterLevelGroup.style.transition = 'transform 0.7s cubic-bezier(0.65, 0, 0.35, 1)';
                }, 50);
            }
            waterAmountDisplay.textContent = Math.round(window.currentWater);
        }

        function updateWaterOnServer() {
            // Converter ML de volta para copos para o servidor
            const waterInCups = Math.round(window.currentWater / CUP_SIZE_ML);
            
            authenticatedFetch(`${window.BASE_APP_URL}/api/update_water.php`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    water_consumed: waterInCups
                })
            })
            .then(async response => {
                if (!response) {
                    throw new Error('Resposta vazia do servidor');
                }
                if (!response.ok) {
                    const text = await response.text();
                    console.error('Erro ao atualizar água:', text);
                    throw new Error(`Erro do Servidor: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Animar estrela voando se ganhou pontos
                    if (data.points_awarded != 0 && data.points_awarded > 0) {
                        // Encontrar o elemento de água para usar como origem da estrela
                        const waterContainer = document.querySelector('.water-tracker-container') || 
                                              document.querySelector('.water-section') ||
                                              document.querySelector('.water-counter');
                        showPointsWithStarAnimation(
                            `+${data.points_awarded} Pontos`,
                            waterContainer || document.body,
                            data.points_awarded,
                            data.new_total_points
                        );
                    } else if (data.new_total_points !== undefined) {
                        // Se não ganhou pontos mas tem novo total, atualizar normalmente
                        const pointsDisplay = document.getElementById('user-points-display');
                        if (pointsDisplay) {
                            pointsDisplay.textContent = new Intl.NumberFormat('pt-BR').format(data.new_total_points);
                        }
                    }
                } else {
                    console.error('Falha ao atualizar a água no servidor:', data.message);
                }
            })
            .catch(err => {
                 console.error('Erro de conexão ou no servidor ao atualizar a água.', err);
            });
        }
        
		function clampToNonNegativeInteger(value) { value = Number(value) || 0; return value < 0 ? 0 : value; }
		function parseAmountToMl(amountValue) {
			const raw = String(amountValue || '').trim().toLowerCase();
			if (raw.endsWith('l') || (waterUnitSelect && waterUnitSelect.value === 'l')) {
				const n = parseFloat(raw.replace('l', '')) || 0;
				return Math.max(0, Math.round(n * 1000));
			}
			return Math.max(0, Math.round(parseFloat(raw) || 0));
		}

        let updateTimeout = null;
        function scheduleServerUpdate() {
            if (updateTimeout) clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => { updateWaterOnServer(); }, 600);
        }

        function mlToCups(ml) { return clampToNonNegativeInteger(Math.round((ml || 0) / CUP_SIZE_ML)); }

        function addMlAndUpdate(mlToAdd) {
            if (mlToAdd <= 0) return;
            window.currentWater = clampToNonNegativeInteger(window.currentWater + mlToAdd);
            updateWaterDrop();
            updateWaterOnServer();
        }

        function subMlAndUpdate(mlToSub) {
            if (mlToSub <= 0) return;
            window.currentWater = clampToNonNegativeInteger(window.currentWater - mlToSub);
            updateWaterDrop();
            updateWaterOnServer();
        }

        function updateControlsEnabled() {
            const amountMl = parseAmountToMl(waterAmountInput && waterAmountInput.value);
            const hasAmount = amountMl > 0;
            if (waterAddBtn) waterAddBtn.disabled = !hasAmount;
            if (waterRemoveBtn) waterRemoveBtn.disabled = !hasAmount;
        }

        if (waterAddBtn) {
            waterAddBtn.addEventListener('click', () => {
                let amountMl = parseAmountToMl(waterAmountInput && waterAmountInput.value);
                if (amountMl <= 0) return;
                addMlAndUpdate(amountMl);
                if (waterAmountInput) { waterAmountInput.value = ''; updateControlsEnabled(); }
            });
        }

		const waterRemoveBtn = document.getElementById('water-remove-btn');
		const waterRemoveFull = document.getElementById('water-remove-full');
        if (waterRemoveBtn) {
            waterRemoveBtn.addEventListener('click', () => {
				let amountMl = parseAmountToMl(waterAmountInput && waterAmountInput.value);
				if (amountMl <= 0) return;
                subMlAndUpdate(amountMl);
				if (waterAmountInput) { waterAmountInput.value = ''; updateControlsEnabled(); }
            });
        }
        if (waterRemoveFull) {
            waterRemoveFull.addEventListener('click', () => {
				let amountMl = parseAmountToMl(waterAmountInput && waterAmountInput.value);
				if (amountMl <= 0) return;
                subMlAndUpdate(amountMl);
				if (waterAmountInput) { waterAmountInput.value = ''; updateControlsEnabled(); }
            });
        }

		// Removidos chips de adição rápida conforme o design

        // Habilita/desabilita botões conforme o usuário digita
        if (waterAmountInput) {
            waterAmountInput.addEventListener('input', updateControlsEnabled);
        }
        if (waterUnitSelect) {
            waterUnitSelect.addEventListener('change', updateControlsEnabled);
        }

        // Verificar se elementos existem antes de chamar updateWaterDrop
        // Re-atualizar referências dos elementos (podem ter mudado após navegação SPA)
        waterLevelGroup = document.getElementById('water-level-group');
        waterAmountDisplay = document.getElementById('water-amount-display');
        if (waterLevelGroup && waterAmountDisplay && typeof updateWaterDrop === 'function') {
            updateWaterDrop(false);
        }
        updateControlsEnabled();


        // --- LÓGICA DOS CÍRCULOS DE PROGRESSO ---
        document.querySelectorAll('.progress-circle').forEach(circleElement => {
            const value = parseFloat(circleElement.dataset.value) || 0;
            const goal = parseFloat(circleElement.dataset.goal) || 1;
            const circle = circleElement.querySelector('.circle');
            const radius = 15.9155;
            const circumference = 2 * Math.PI * radius;
            
            let percent = (value / goal);
            if (percent > 1) percent = 1;
            if (percent < 0) percent = 0;

            const offset = circumference - (percent * circumference);

            circle.style.strokeDasharray = `${circumference} ${circumference}`;
            setTimeout(() => {
                circle.style.strokeDashoffset = offset;
            }, 100);
        });

        // --- FUNCIONALIDADE DE SONO ---
        
        // Event listeners para fechar modal
        document.addEventListener('click', function(e) {
            if (e.target.closest('[data-action="close-modal"]')) {
                const modal = document.getElementById('sleep-modal-main');
                if (modal) {
                    modal.classList.remove('modal-visible');
                    document.body.style.overflow = '';
                }
            }
        });
        

    });


</script>

    <!-- Botão Flutuante de Check-in -->
    <button class="checkin-floating-btn" id="checkin-floating-btn" onclick="openCheckinModal()" aria-label="Abrir Check-in" style="display: none;">
        <i class="fas fa-comments"></i>
    </button>
    
    <!-- Bottom Navigation (via JavaScript - funciona como include) -->
    <script>
        const bottomNavScript = document.createElement('script');
        bottomNavScript.src = './assets/js/bottom-nav.js?v=' + Date.now();
        document.head.appendChild(bottomNavScript);
    </script>

<style>
/* Check-in Floating Button */
.checkin-floating-btn {
    position: fixed;
    bottom: 90px;
    right: 20px;
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: rgba(255, 107, 0, 0.2);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 107, 0, 0.4);
    color: #FF6B00;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 4px 20px rgba(255, 107, 0, 0.25),
                0 2px 8px rgba(0, 0, 0, 0.2),
                0 0 0 0 rgba(255, 107, 0, 0.4);
    transition: all 0.3s ease;
    z-index: 999;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: float-gentle 3s ease-in-out infinite;
}

#dashboard-container.app-container {
    padding-bottom: calc(100px + env(safe-area-inset-bottom, 0px));
}

@keyframes float-gentle {
    0%, 100% {
        transform: translateY(0px);
    }
    50% {
        transform: translateY(-8px);
    }
}

.checkin-floating-btn:hover {
    background: rgba(255, 107, 0, 0.3);
    border-color: rgba(255, 107, 0, 0.6);
    animation: none;
    transform: translateY(-4px);
    box-shadow: 0 6px 24px rgba(255, 107, 0, 0.35),
                0 4px 12px rgba(0, 0, 0, 0.25),
                0 0 0 2px rgba(255, 107, 0, 0.2);
}

.checkin-floating-btn:active {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(255, 107, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.2),
                0 0 0 1px rgba(255, 107, 0, 0.15);
}

@media (max-width: 768px) {
    .checkin-floating-btn {
        bottom: calc(80px + env(safe-area-inset-bottom));
        right: 16px;
        width: 60px;
        height: 60px;
        font-size: 22px;
    }
}

@media (min-width: 769px) {
    .checkin-floating-btn {
        bottom: 100px;
    }
}

/* Check-in Modal (Clean Glassmorphism Style) */
.checkin-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    z-index: 10000;
    align-items: center;
    justify-content: center;
    padding: calc(12px + env(safe-area-inset-top, 0px)) 12px env(safe-area-inset-bottom, 0px);
    overflow: hidden;
    /* Garantir que cliques no background funcionem */
    cursor: pointer;
    touch-action: auto;
}

.checkin-chat-container {
    width: 100%;
    max-width: 500px;
    height: 90vh;
    max-height: calc(800px + env(safe-area-inset-bottom, 0px));
    background: rgba(30, 30, 30, 0.4);
    backdrop-filter: blur(50px);
    -webkit-backdrop-filter: blur(50px);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.15);
    position: relative;
    z-index: 1;
    margin: 0 auto;
    /* Prevenir que cliques no container fechem o modal */
    cursor: default;
    pointer-events: auto;
    /* Permitir gestos padrão (scroll) dentro do container */
    touch-action: auto;
}

.checkin-chat-header {
    background: rgba(30, 30, 30, 0.4);
    backdrop-filter: blur(50px);
    -webkit-backdrop-filter: blur(50px);
    padding: 16px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    z-index: 10;
    flex-shrink: 0; /* Prevent header from shrinking */
}

.checkin-chat-header h3 {
    margin: 0;
    color: #FFFFFF;
    font-size: 1.1rem;
    font-weight: 600;
}

.checkin-close-btn {
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.6);
    font-size: 1.3rem;
    cursor: pointer;
    padding: 0;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
    line-height: 1;
    font-weight: 300;
    position: relative;
    z-index: 10001;
    pointer-events: auto;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
}

.checkin-close-btn:hover {
    background: rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.9);
}

.checkin-close-btn:active {
    background: rgba(255, 255, 255, 0.15);
    transform: scale(0.95);
}

.checkin-messages {
    flex: 1 1 auto;
    overflow-y: scroll !important;
    overflow-x: hidden;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    background: rgba(30, 30, 30, 0.4);
    backdrop-filter: blur(50px);
    -webkit-backdrop-filter: blur(50px);
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
    /* Touch scrolling - ESSENCIAL para mobile */
    -webkit-overflow-scrolling: touch !important;
    touch-action: pan-y !important;
    overscroll-behavior: contain;
    will-change: scroll-position;
    min-height: 0;
    position: relative;
    z-index: 2;
    /* Force hardware acceleration */
    transform: translateZ(0);
    -webkit-transform: translateZ(0);
    /* Garantir que o elemento seja scrollável */
    height: 100%;
    /* Permitir eventos de touch */
    pointer-events: auto;
    -webkit-user-select: none;
    user-select: none;
}

.checkin-messages::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}

.checkin-message {
    max-width: 75%;
    padding: 12px 16px;
    border-radius: 8px;
    word-wrap: break-word;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.checkin-message.bot {
    align-self: flex-start;
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    color: #FFFFFF;
    border-radius: 18px;
    border-bottom-left-radius: 4px;
}

.checkin-message.user {
    align-self: flex-end;
    background: #FF6B00;
    color: #FFFFFF;
    font-weight: 500;
    border-radius: 18px;
    border-bottom-right-radius: 4px;
}

.checkin-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
}

.checkin-option-btn {
    padding: 12px 16px;
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    color: #FFFFFF;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: left;
    font-size: 0.95rem;
    font-weight: 400;
}

.checkin-option-btn:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.12);
    border-color: rgba(255, 255, 255, 0.2);
    transform: translateY(-1px);
}

.checkin-option-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.checkin-input-container {
    padding: 16px;
    padding-bottom: 16px;
    background: rgba(30, 30, 30, 0.4);
    backdrop-filter: blur(50px);
    -webkit-backdrop-filter: blur(50px);
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    gap: 12px;
    align-items: center;
    flex-shrink: 0; /* Prevent input container from shrinking */
    position: relative;
    z-index: 10;
}

body.checkin-modal-open .checkin-input-container {
    padding-bottom: 16px;
}

.checkin-text-input {
    flex: 1;
    padding: 12px 16px;
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
    color: #FFFFFF;
    font-size: 0.95rem;
    outline: none;
    font-family: inherit;
    transition: all 0.2s ease;
}

.checkin-text-input:focus {
    border-color: rgba(255, 255, 255, 0.2);
    background: rgba(255, 255, 255, 0.1);
}

.checkin-text-input:disabled {
    background: rgba(255, 255, 255, 0.03);
    color: rgba(255, 255, 255, 0.4);
    cursor: not-allowed;
    opacity: 0.6;
    border-color: rgba(255, 255, 255, 0.05);
}

.checkin-text-input::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

.checkin-send-btn {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: rgba(255, 107, 0, 0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 107, 0, 0.3);
    color: #FF6B00;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    flex-shrink: 0;
    padding: 0;
    margin: 0;
}

.checkin-send-btn i {
    font-size: 1rem;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
}

.checkin-send-btn:hover:not(:disabled) {
    background: rgba(255, 107, 0, 0.3);
    border-color: rgba(255, 107, 0, 0.5);
    color: #FF8533;
    transform: scale(1.05);
}

.checkin-send-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    transform: none;
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.3);
}
</style>

<!-- Check-in Modal -->
<div class="checkin-modal" id="checkinModal" style="display: none;">
    <div class="checkin-chat-container">
        <div class="checkin-chat-header">
            <h3 id="checkin-title">Check-in</h3>
            <button class="checkin-close-btn" onclick="closeCheckinModal()">&times;</button>
        </div>
        <div class="checkin-messages" id="checkinMessages"></div>
        <div class="checkin-input-container" id="checkinInputContainer">
            <input type="text" class="checkin-text-input" id="checkinTextInput" placeholder="Digite sua resposta..." onkeypress="if(event.key === 'Enter') sendCheckinResponse()" disabled>
            <button class="checkin-send-btn" onclick="sendCheckinResponse()" id="checkinSendBtn" disabled>
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>
</div>

<script>
let checkinData = window.checkinData || null;
let currentQuestionIndex = 0;
let checkinResponses = {};
let savedResponses = {};
let answeredQuestionIds = [];

function openCheckinModal() {
    const modal = document.getElementById('checkinModal');
    if (!modal) {
        console.error('Modal de checkin não encontrado');
        return;
    }
    
    // Verificar se há checkin disponível
    if (!checkinData && window.checkinData) {
        checkinData = window.checkinData;
    }
    
    if (!checkinData) {
        console.error('Nenhum checkin disponível');
        alert('Nenhum check-in disponível no momento.');
        return;
    }
    
    // Abrir modal - garantir que está visível
    modal.classList.add('active');
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.setAttribute('aria-hidden', 'false');
    
        // Bloquear scroll do body (sem alterar posicionamento fixo do layout)
        document.body.classList.add('checkin-modal-open');
    
    // Limpar mensagens anteriores
    const messagesContainer = document.getElementById('checkinMessages');
    if (messagesContainer) {
        messagesContainer.innerHTML = '';
    }
    
    // Configurar event listeners quando o modal abre
    setupCheckinModalEvents();
    
    // Garantir que o scroll funcione no chat (touch) - SOLUÇÃO ROBUSTA
    setTimeout(() => {
        const messagesContainer = document.getElementById('checkinMessages');
        if (messagesContainer) {
            // Forçar propriedades de scroll touch via JavaScript
            messagesContainer.style.overflowY = 'scroll';
            messagesContainer.style.webkitOverflowScrolling = 'touch';
            messagesContainer.style.touchAction = 'pan-y';
            messagesContainer.style.overflowScrolling = 'touch';
            messagesContainer.style.pointerEvents = 'auto';
            
            // Remover qualquer listener que possa estar bloqueando
            messagesContainer.addEventListener('touchstart', function(e) {
                // Permitir que o scroll aconteça naturalmente
                // Não fazer preventDefault aqui
            }, { passive: true });
            
            messagesContainer.addEventListener('touchmove', function(e) {
                // Permitir scroll natural - NÃO bloquear
                // Se o elemento está scrollando, não fazer nada
                const element = e.currentTarget;
                const isScrolling = element.scrollHeight > element.clientHeight;
                
                if (isScrolling) {
                    // Se há conteúdo para scrollar, permitir
                    // Não fazer preventDefault
                }
            }, { passive: true });
            
            messagesContainer.addEventListener('touchend', function(e) {
                // Permitir que o touch end aconteça normalmente
            }, { passive: true });
            
            // Garantir que o elemento tenha conteúdo suficiente para scrollar
            if (messagesContainer.scrollHeight <= messagesContainer.clientHeight) {
                // Adicionar padding bottom temporário para forçar scroll
                messagesContainer.style.paddingBottom = '100px';
            }
            
            console.log('[Check-in] Scroll touch configurado - scrollHeight:', messagesContainer.scrollHeight, 'clientHeight:', messagesContainer.clientHeight);
        }
    }, 100);
    
    // Carregar progresso salvo
    loadCheckinProgress();
}

// Flag para evitar adicionar listeners múltiplas vezes
let checkinModalEventsSetup = false;

function setupCheckinModalEvents() {
    const modal = document.getElementById('checkinModal');
    if (!modal) return;
    
    // Se já configurado, não fazer novamente
    if (checkinModalEventsSetup && modal.dataset.eventsSetup === 'true') {
        return;
    }
    
    // Fechar ao clicar no background (fora do container)
    modal.addEventListener('click', function modalClickHandler(e) {
        // Se clicou diretamente no modal (background), fechar
        // MAS não fechar se o clique foi no container ou dentro dele
        const container = modal.querySelector('.checkin-chat-container');
        if (e.target === modal || (e.target.classList.contains('checkin-modal') && !container.contains(e.target))) {
            e.preventDefault();
            e.stopPropagation();
            closeCheckinModal();
            return false;
        }
    });
    
    // Também funcionar com touch - mas só se não foi no container
    modal.addEventListener('touchend', function modalTouchHandler(e) {
        const container = modal.querySelector('.checkin-chat-container');
        if ((e.target === modal || e.target.classList.contains('checkin-modal')) && !container.contains(e.target)) {
            e.preventDefault();
            e.stopPropagation();
            closeCheckinModal();
            return false;
        }
    }, { passive: false });
    
    // Garantir que o botão de fechar funcione
    const closeBtn = modal.querySelector('.checkin-close-btn');
    if (closeBtn) {
        // Remover todos os event listeners antigos
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
        
        // Adicionar event listeners diretos
        newCloseBtn.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('[Check-in] Botão X clicado');
            closeCheckinModal();
            return false;
        };
        
        newCloseBtn.ontouchend = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('[Check-in] Botão X tocado');
            closeCheckinModal();
            return false;
        };
        
        // Também adicionar via addEventListener como backup
        newCloseBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            closeCheckinModal();
        }, true);
        
        newCloseBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            e.stopPropagation();
            closeCheckinModal();
        }, true);
    }
    
    // Prevenir que cliques dentro do container fechem o modal
    const container = modal.querySelector('.checkin-chat-container');
    if (container) {
        container.addEventListener('click', function(e) {
            e.stopPropagation();
        });
    }
    
    // Marcar como configurado
    modal.dataset.eventsSetup = 'true';
    checkinModalEventsSetup = true;
}

function closeCheckinModal() {
    const modal = document.getElementById('checkinModal');
    if (!modal) {
        console.error('[Check-in] Modal não encontrado para fechar');
        return;
    }
    
    // Salvar progresso antes de fechar o modal
    if (checkinData && Object.keys(checkinResponses).length > 0) {
        saveCheckinProgressToLocalStorage();
        console.log('[Check-in] Progresso salvo ao fechar modal');
    }
    
    // Forçar fechamento do modal - múltiplas formas para garantir
    modal.classList.remove('active');
    modal.style.display = 'none';
    modal.style.visibility = 'hidden';
    modal.style.opacity = '0';
    modal.setAttribute('aria-hidden', 'true');
    
    // Restaurar scroll do body
    document.body.classList.remove('checkin-modal-open');
    
    console.log('[Check-in] Modal fechado - display:', modal.style.display, 'classList:', modal.classList.toString());
    
    // Não resetar o progresso - manter para continuar depois
}

// Configurar eventos iniciais do modal (fallback caso o modal já esteja no DOM)
document.addEventListener('DOMContentLoaded', function() {
    setupCheckinModalEvents();
});

// Função para calcular o domingo da semana atual (mesma lógica do backend)
function getCurrentWeekStart() {
    const today = new Date();
    const dayOfWeek = today.getDay(); // 0 = domingo, 1 = segunda, etc.
    const diff = dayOfWeek; // Diferença até o domingo (0 se já for domingo)
    const sunday = new Date(today);
    sunday.setDate(today.getDate() - diff);
    sunday.setHours(0, 0, 0, 0);
    // Formato YYYY-MM-DD (usar data local, não UTC)
    const year = sunday.getFullYear();
    const month = String(sunday.getMonth() + 1).padStart(2, '0');
    const day = String(sunday.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

function loadCheckinProgress() {
    // Primeiro, tentar carregar do localStorage (progresso local)
    const currentWeek = getCurrentWeekStart();
    const storageKey = `checkin_progress_${checkinData.id}_${currentWeek}`;
    const savedProgress = localStorage.getItem(storageKey);
    
    if (savedProgress) {
        try {
            const progress = JSON.parse(savedProgress);
            console.log('[Check-in] Progresso carregado do localStorage:', progress);
            
            // Verificar se o progresso é da semana atual
            const savedWeek = progress.week_start || progress.week_date;
            if (savedWeek !== currentWeek) {
                console.log('[Check-in] Progresso de semana diferente detectado. Limpando localStorage antigo.');
                console.log('[Check-in] Semana salva:', savedWeek, '| Semana atual:', currentWeek);
                // Limpar progresso antigo
                localStorage.removeItem(storageKey);
                // Limpar também chaves antigas sem semana (compatibilidade)
                const oldKey = `checkin_progress_${checkinData.id}`;
                localStorage.removeItem(oldKey);
                // Começar do zero
                currentQuestionIndex = 0;
                checkinResponses = {};
                const textInput = document.getElementById('checkinTextInput');
                const sendBtn = document.getElementById('checkinSendBtn');
                textInput.disabled = true;
                sendBtn.disabled = true;
                textInput.value = '';
                renderNextQuestion();
                return;
            }
            
            // Restaurar respostas e índice - fazer deep copy para evitar referências
            const loadedResponses = progress.responses || {};
            checkinResponses = {};
            
            // Fazer deep copy das respostas carregadas
            Object.keys(loadedResponses).forEach(key => {
                const numKey = Number(key);
                checkinResponses[numKey] = {
                    response_text: loadedResponses[key].response_text || null,
                    response_value: loadedResponses[key].response_value || null
                };
                // Manter também a chave original para compatibilidade
                checkinResponses[key] = checkinResponses[numKey];
            });
            
            currentQuestionIndex = Number(progress.currentQuestionIndex) || 0;
            
            // Garantir que as chaves de savedResponses sejam numéricas
            savedResponses = {};
            Object.keys(checkinResponses).forEach(key => {
                const numKey = Number(key);
                if (!isNaN(numKey)) {
                    savedResponses[numKey] = checkinResponses[numKey];
                }
                savedResponses[key] = checkinResponses[key]; // Manter ambas as formas para compatibilidade
            });
            
            answeredQuestionIds = Object.keys(checkinResponses)
                .filter(key => !isNaN(Number(key)))
                .map(id => Number(id));
            
            console.log('[Check-in] Respostas salvas localmente:', savedResponses);
            console.log('[Check-in] IDs de perguntas respondidas:', answeredQuestionIds);
            
            // Se já temos respostas salvas, restaurar o chat
            if (answeredQuestionIds.length > 0) {
                console.log('[Check-in] Restaurando chat do progresso salvo localmente...');
                restoreChatFromProgress();
                return; // Não precisa buscar do servidor
            }
        } catch (error) {
            console.error('[Check-in] Erro ao carregar do localStorage:', error);
            // Continuar para buscar do servidor como fallback
        }
    }
    
    // Se não tem no localStorage, verificar no servidor (apenas para checkins já completados)
    // Mas não vamos salvar individualmente durante o fluxo, então isso é só para verificar se já foi completado
    const formData = new FormData();
    formData.append('action', 'load_progress');
    formData.append('config_id', checkinData.id);
    
    authenticatedFetch(`${window.BASE_APP_URL}/api/checkin.php`, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (!response) return null;
        return response.json();
    })
    .then(data => {
        console.log('[Check-in] Dados do servidor:', data);
        if (data && data.success) {
            // Se o servidor retornou respostas vazias, significa que o checkin já foi completado
            // ou não há progresso salvo. Nesse caso, começar do início
            if (!data.responses || Object.keys(data.responses).length === 0) {
                console.log('[Check-in] Nenhuma resposta salva encontrada, começando do início');
                currentQuestionIndex = 0;
                checkinResponses = {};
                const textInput = document.getElementById('checkinTextInput');
                const sendBtn = document.getElementById('checkinSendBtn');
                textInput.disabled = true;
                sendBtn.disabled = true;
                textInput.value = '';
                renderNextQuestion();
            } else {
                // Se o servidor tem respostas, usar elas (caso raro de sincronização)
                savedResponses = {};
                const responses = data.responses || {};
                Object.keys(responses).forEach(key => {
                    const numKey = Number(key);
                    savedResponses[numKey] = responses[key];
                    savedResponses[key] = responses[key];
                });
                
                answeredQuestionIds = (data.answered_questions || []).map(id => Number(id));
                checkinResponses = savedResponses;
                
                console.log('[Check-in] Restaurando chat do progresso do servidor...');
                restoreChatFromProgress();
            }
        } else {
            // Se erro, começar do início
            currentQuestionIndex = 0;
            checkinResponses = {};
            const textInput = document.getElementById('checkinTextInput');
            const sendBtn = document.getElementById('checkinSendBtn');
            textInput.disabled = true;
            sendBtn.disabled = true;
            textInput.value = '';
            renderNextQuestion();
        }
    })
    .catch(error => {
        console.error('Erro ao carregar progresso do servidor:', error);
        // Em caso de erro, começar do início
        currentQuestionIndex = 0;
        checkinResponses = {};
        const textInput = document.getElementById('checkinTextInput');
        const sendBtn = document.getElementById('checkinSendBtn');
        textInput.disabled = true;
        sendBtn.disabled = true;
        textInput.value = '';
        renderNextQuestion();
    });
}

function restoreChatFromProgress() {
    const messagesDiv = document.getElementById('checkinMessages');
    messagesDiv.innerHTML = ''; // Limpar mensagens anteriores
    
    console.log('[Check-in] Restaurando chat - Total de perguntas:', checkinData.questions.length);
    console.log('[Check-in] Perguntas respondidas:', answeredQuestionIds);
    console.log('[Check-in] Índice atual da pergunta:', currentQuestionIndex);
    
    // Garantir que answeredQuestionIds e question.id são do mesmo tipo para comparação
    const answeredQuestionIdsNum = answeredQuestionIds.map(id => Number(id));
    
    // Renderizar todas as perguntas já respondidas
    for (let i = 0; i < checkinData.questions.length; i++) {
        const question = checkinData.questions[i];
        const questionIdNum = Number(question.id);
        
        if (answeredQuestionIdsNum.includes(questionIdNum)) {
            console.log('[Check-in] Restaurando pergunta:', questionIdNum, question.question_text);
            // Renderizar pergunta
            addMessage(question.question_text, 'bot');
            
            // Se for múltipla escolha ou escala, renderizar as opções (desabilitadas)
            if ((question.question_type === 'scale' || question.question_type === 'multiple_choice') && question.options) {
                const options = Array.isArray(question.options) ? question.options : JSON.parse(question.options);
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'checkin-options';
                
                options.forEach(option => {
                    const btn = document.createElement('button');
                    btn.className = 'checkin-option-btn';
                    btn.type = 'button';
                    btn.textContent = option;
                    btn.disabled = true;
                    btn.style.opacity = '0.4';
                    btn.style.cursor = 'not-allowed';
                    optionsDiv.appendChild(btn);
                });
                
                messagesDiv.appendChild(optionsDiv);
            }
            
            // Renderizar resposta do usuário
            const savedResponse = savedResponses[questionIdNum] || savedResponses[question.id];
            if (savedResponse) {
                if (savedResponse.response_text) {
                    addMessage(savedResponse.response_text, 'user');
                } else if (savedResponse.response_value) {
                    addMessage(savedResponse.response_value, 'user');
                }
            }
            
            // Garantir que a resposta está no checkinResponses
            checkinResponses[questionIdNum] = savedResponse;
        }
    }
    
    // Usar o currentQuestionIndex que já foi carregado do localStorage (ou calcular se não foi)
    // Se currentQuestionIndex não foi definido, calcular baseado nas respostas
    if (currentQuestionIndex === undefined || currentQuestionIndex === null) {
        let lastAnsweredIndex = -1;
        for (let i = 0; i < checkinData.questions.length; i++) {
            const question = checkinData.questions[i];
            const questionIdNum = Number(question.id);
            if (answeredQuestionIdsNum.includes(questionIdNum)) {
                lastAnsweredIndex = i;
            }
        }
        currentQuestionIndex = lastAnsweredIndex + 1;
    }
    
    // Verificar se todas as perguntas foram respondidas
    // Mas só completar se realmente todas foram respondidas E não foram puladas por lógica condicional
    let totalAnswered = 0;
    for (let i = 0; i < checkinData.questions.length; i++) {
        const question = checkinData.questions[i];
        const questionIdNum = Number(question.id);
        // Contar apenas perguntas que foram respondidas OU que foram puladas por lógica condicional
        if (answeredQuestionIdsNum.includes(questionIdNum) || !shouldShowQuestion(question)) {
            totalAnswered++;
        }
    }
    
    console.log('[Check-in] Total respondido:', totalAnswered, 'de', checkinData.questions.length);
    console.log('[Check-in] Próximo índice:', currentQuestionIndex);
    
    if (currentQuestionIndex >= checkinData.questions.length || totalAnswered >= checkinData.questions.length) {
        // Todas as perguntas foram respondidas
        addMessage('Obrigado pelo seu feedback! Seu check-in foi salvo com sucesso.', 'bot');
        const textInput = document.getElementById('checkinTextInput');
        const sendBtn = document.getElementById('checkinSendBtn');
        textInput.disabled = true;
        sendBtn.disabled = true;
        textInput.value = '';
        textInput.placeholder = 'Check-in finalizado';
        
        // Marcar como completo
        markCheckinComplete();
    } else {
        // Renderizar próxima pergunta
        renderNextQuestion();
    }
}

// Função para verificar se uma pergunta deve ser mostrada baseada em condições
function shouldShowQuestion(question) {
    // Se não tem lógica condicional, sempre mostrar
    if (!question.conditional_logic) {
        return true;
    }
    
    try {
        const condition = typeof question.conditional_logic === 'string' 
            ? JSON.parse(question.conditional_logic) 
            : question.conditional_logic;
        
        // Verificar se depende de uma pergunta anterior
        if (condition.depends_on_question_id) {
            const dependsOnId = condition.depends_on_question_id;
            const previousResponse = checkinResponses[dependsOnId];
            
            if (!previousResponse) {
                // Se não há resposta para a pergunta dependente, não mostrar
                return false;
            }
            
            // Verificar o valor da resposta
            const responseValue = previousResponse.response_value || previousResponse.response_text || '';
            
            // Se show_if_value é um array, verificar se a resposta está no array
            if (Array.isArray(condition.show_if_value)) {
                return condition.show_if_value.includes(responseValue);
            }
            // Se é um valor único, verificar se corresponde
            else if (condition.show_if_value) {
                return responseValue === condition.show_if_value;
            }
            // Se não especifica valor, mostrar se houver resposta
            else {
                return true;
            }
        }
        
        // Se não tem dependência definida, mostrar
        return true;
    } catch (e) {
        console.error('Erro ao processar lógica condicional:', e);
        // Em caso de erro, mostrar a pergunta por segurança
        return true;
    }
}

function renderNextQuestion() {
    const messagesDiv = document.getElementById('checkinMessages');
    const inputContainer = document.getElementById('checkinInputContainer');
    const textInput = document.getElementById('checkinTextInput');
    const sendBtn = document.getElementById('checkinSendBtn');
    
    // Pular perguntas que não devem ser mostradas
    while (currentQuestionIndex < checkinData.questions.length) {
        const question = checkinData.questions[currentQuestionIndex];
        
        if (shouldShowQuestion(question)) {
            // Esta pergunta deve ser mostrada
            break;
        } else {
            // Pular esta pergunta
            console.log('Pulando pergunta', question.id, 'devido a condição não atendida');
            currentQuestionIndex++;
        }
    }
    
    if (currentQuestionIndex >= checkinData.questions.length) {
        // Todas as perguntas foram respondidas ou puladas
        addMessage('Obrigado pelo seu feedback! Seu check-in foi salvo com sucesso.', 'bot');
        textInput.disabled = true;
        sendBtn.disabled = true;
        textInput.value = '';
        textInput.placeholder = 'Check-in finalizado';
        
        // Marcar como completo (todas as respostas já foram salvas individualmente)
        markCheckinComplete();
        return;
    }
    
    const question = checkinData.questions[currentQuestionIndex];
    
    // Adicionar mensagem da pergunta
    addMessage(question.question_text, 'bot');
    
    // Habilitar ou desabilitar input baseado no tipo
    if (question.question_type === 'text') {
        textInput.disabled = false;
        sendBtn.disabled = false;
        textInput.value = '';
        textInput.placeholder = 'Digite sua resposta...';
    } else {
        // Múltipla escolha ou escala - desabilitar input
        textInput.disabled = true;
        sendBtn.disabled = true;
        textInput.value = '';
        textInput.placeholder = 'Selecione uma opção acima...';
        showQuestionOptions(question);
    }
}

function showQuestionOptions(question) {
    const messagesDiv = document.getElementById('checkinMessages');
    const optionsDiv = document.createElement('div');
    optionsDiv.className = 'checkin-options';
    
    if ((question.question_type === 'scale' || question.question_type === 'multiple_choice') && question.options) {
        const options = Array.isArray(question.options) ? question.options : JSON.parse(question.options);
        options.forEach(option => {
            const btn = document.createElement('button');
            btn.className = 'checkin-option-btn';
            btn.type = 'button';
            btn.textContent = option;
            btn.onclick = () => selectOption(option);
            optionsDiv.appendChild(btn);
        });
        
        messagesDiv.appendChild(optionsDiv);
        // Scroll suave para o final
        setTimeout(() => {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }, 100);
    }
}

function selectOption(option) {
    // Desabilitar todos os botões de opção para evitar múltiplos cliques
    const optionButtons = document.querySelectorAll('.checkin-option-btn');
    optionButtons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.4';
        btn.style.cursor = 'not-allowed';
    });
    
    const question = checkinData.questions[currentQuestionIndex];
    const questionId = Number(question.id); // Garantir que seja numérico
    const response = {
        response_value: option,
        response_text: null
    };
    
    // Salvar com chave numérica para consistência
    checkinResponses[questionId] = response;
    
    addMessage(option, 'user');
    
    // Salvar progresso no localStorage (não no backend ainda)
    saveCheckinProgressToLocalStorage();
    
    currentQuestionIndex++;
    setTimeout(() => renderNextQuestion(), 500);
}

function sendCheckinResponse() {
    const input = document.getElementById('checkinTextInput');
    const sendBtn = document.getElementById('checkinSendBtn');
    
    // Verificar se está desabilitado
    if (input.disabled) return;
    
    const response = input.value.trim();
    if (!response) return;
    
    const question = checkinData.questions[currentQuestionIndex];
    const questionId = Number(question.id); // Garantir que seja numérico
    const responseData = {
        response_text: response,
        response_value: null
    };
    
    // Salvar com chave numérica para consistência
    checkinResponses[questionId] = responseData;
    
    addMessage(response, 'user');
    input.value = '';
    input.disabled = true;
    sendBtn.disabled = true;
    
    // Salvar progresso no localStorage (não no backend ainda)
    saveCheckinProgressToLocalStorage();
    
    currentQuestionIndex++;
    setTimeout(() => renderNextQuestion(), 500);
}

// Variável para controlar debounce do salvamento
let saveCheckinProgressTimeout = null;

function saveCheckinProgressToLocalStorage() {
    // Salvar progresso no localStorage em vez de salvar individualmente no backend
    // Fazer deep copy para garantir que o objeto seja salvo corretamente
    if (!checkinData || !checkinData.id) {
        console.error('[Check-in] checkinData não está disponível para salvar');
        return;
    }
    
    // Debounce: cancelar salvamento anterior se houver um pendente
    if (saveCheckinProgressTimeout) {
        clearTimeout(saveCheckinProgressTimeout);
    }
    
    // Executar salvamento após pequeno delay para evitar múltiplas escritas
    saveCheckinProgressTimeout = setTimeout(() => {
        _saveCheckinProgressToLocalStorage();
        saveCheckinProgressTimeout = null;
    }, 100);
}

function _saveCheckinProgressToLocalStorage() {
    // Incluir a semana atual na chave para isolar progresso por semana
    const currentWeek = getCurrentWeekStart();
    const storageKey = `checkin_progress_${checkinData.id}_${currentWeek}`;
    
    // Limpar progressos antigos de outras semanas para o mesmo checkin
    clearOldCheckinProgressForConfig(checkinData.id, currentWeek);
    
    // Criar uma cópia profunda das respostas para garantir que seja salva corretamente
    // Filtrar apenas chaves numéricas válidas
    const responsesCopy = {};
    Object.keys(checkinResponses).forEach(key => {
        const numKey = Number(key);
        // Só incluir se for uma chave numérica válida e tiver dados
        if (!isNaN(numKey) && checkinResponses[key]) {
            responsesCopy[numKey] = {
                response_text: checkinResponses[key].response_text || null,
                response_value: checkinResponses[key].response_value || null
            };
        }
    });
    
    const progress = {
        responses: responsesCopy,
        currentQuestionIndex: Number(currentQuestionIndex) || 0,
        timestamp: Date.now(),
        config_id: Number(checkinData.id),
        week_start: currentWeek // Salvar a semana para validação
    };
    
    try {
        const serialized = JSON.stringify(progress);
        localStorage.setItem(storageKey, serialized);
        console.log('[Check-in] Progresso salvo no localStorage:', {
            total_responses: Object.keys(responsesCopy).length,
            current_index: currentQuestionIndex,
            question_ids: Object.keys(responsesCopy).join(', ')
        });
    } catch (error) {
        console.error('[Check-in] Erro ao salvar no localStorage:', error);
        // Se o localStorage estiver cheio, tentar limpar dados antigos
        if (error.name === 'QuotaExceededError' || error.code === 22) {
            console.warn('[Check-in] localStorage cheio, tentando limpar dados antigos...');
            clearOldCheckinProgress();
            // Tentar novamente
            try {
                localStorage.setItem(storageKey, JSON.stringify(progress));
                console.log('[Check-in] Progresso salvo após limpeza');
            } catch (retryError) {
                console.error('[Check-in] Erro ao salvar após limpeza:', retryError);
            }
        }
    }
}

function clearOldCheckinProgress() {
    // Limpar progressos antigos (mais de 7 dias)
    const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    const keysToRemove = [];
    
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('checkin_progress_')) {
            try {
                const data = JSON.parse(localStorage.getItem(key));
                if (data.timestamp && data.timestamp < sevenDaysAgo) {
                    keysToRemove.push(key);
                }
            } catch (e) {
                // Se não conseguir parsear, remover também
                keysToRemove.push(key);
            }
        }
    }
    
    keysToRemove.forEach(key => {
        localStorage.removeItem(key);
        console.log('[Check-in] Removido progresso antigo:', key);
    });
}

function clearCheckinProgressFromLocalStorage() {
    // Limpar progresso do localStorage após completar o checkin
    if (!checkinData || !checkinData.id) return;
    
    const currentWeek = getCurrentWeekStart();
    const storageKey = `checkin_progress_${checkinData.id}_${currentWeek}`;
    
    try {
        localStorage.removeItem(storageKey);
        console.log('[Check-in] Progresso removido do localStorage');
        
        // Limpar também chave antiga sem semana (compatibilidade)
        const oldKey = `checkin_progress_${checkinData.id}`;
        localStorage.removeItem(oldKey);
    } catch (error) {
        console.error('[Check-in] Erro ao limpar localStorage:', error);
    }
}

function clearOldCheckinProgressForConfig(configId, currentWeek) {
    // Limpar progressos antigos do mesmo checkin mas de semanas diferentes
    const keysToRemove = [];
    
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(`checkin_progress_${configId}_`)) {
            // Se não é da semana atual, remover
            if (!key.endsWith(`_${currentWeek}`)) {
                keysToRemove.push(key);
            }
        }
        // Também limpar chaves antigas sem semana (compatibilidade)
        if (key === `checkin_progress_${configId}`) {
            keysToRemove.push(key);
        }
    }
    
    keysToRemove.forEach(key => {
        localStorage.removeItem(key);
        console.log('[Check-in] Removido progresso antigo:', key);
    });
}

function addMessage(text, type) {
    const messagesDiv = document.getElementById('checkinMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `checkin-message ${type}`;
    messageDiv.textContent = text;
    messagesDiv.appendChild(messageDiv);
    // Scroll suave para o final
    setTimeout(() => {
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }, 50);
}

function markCheckinComplete() {
    const formData = new FormData();
    formData.append('action', 'submit_checkin');
    formData.append('config_id', checkinData.id);
    formData.append('responses', JSON.stringify(checkinResponses));
    
    authenticatedFetch(`${window.BASE_APP_URL}/api/checkin.php`, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (!response) return null;
        return response.json();
    })
    .then(data => {
        if (data.success) {
            console.log('Check-in completo!', data);
            
            // Limpar progresso do localStorage após enviar com sucesso
            clearCheckinProgressFromLocalStorage();
            
            // Fechar o modal imediatamente
                closeCheckinModal();
            
            // Remover o botão flutuante permanentemente (não apenas esconder)
            const floatingBtn = document.querySelector('.checkin-floating-btn');
            if (floatingBtn) {
                floatingBtn.remove(); // Remove do DOM completamente
            }
            
            // Remover o modal também do DOM
            const modal = document.getElementById('checkinModal');
            if (modal) {
                modal.remove();
            }
            
            // Salvar dados da resposta para usar na animação
            window.lastCheckinResponse = data;
            
            // Sempre mostrar popup de congratulação (com ou sem pontos)
            // Pequeno delay para garantir que o modal fechou antes do popup aparecer
            setTimeout(() => {
                const points = data.points_awarded || 0;
                const newTotalPoints = data.new_total_points;
                
                // Se ganhou pontos, mostrar popup e depois atualizar com animação
                if (points > 0 && newTotalPoints !== undefined) {
                    showCheckinCongratsPopup(points);
                    // A atualização dos pontos será feita pela animação da estrela
                } else {
                    // Se não ganhou pontos, apenas mostrar popup
                    showCheckinCongratsPopup(0);
                    // Atualizar pontos normalmente se houver
                    if (newTotalPoints !== undefined) {
                        const pointsDisplay = document.getElementById('user-points-display');
                        if (pointsDisplay) {
                            pointsDisplay.textContent = new Intl.NumberFormat('pt-BR').format(newTotalPoints);
                        }
                    }
                }
            }, 300);
        } else {
            console.error('Erro ao marcar check-in como completo:', data.message);
            alert('Erro ao completar check-in: ' + (data.message || 'Erro desconhecido'));
        }
    })
    .catch(error => {
        console.error('Erro:', error);
        alert('Erro ao completar check-in. Tente novamente.');
    });
}

function showCheckinCongratsPopup(points) {
    // Remover qualquer popup anterior se existir
    const existingPopup = document.querySelector('.checkin-congrats-popup');
    if (existingPopup) {
        existingPopup.remove();
    }
    
    const popup = document.createElement('div');
    popup.className = 'checkin-congrats-popup';
    
    if (points > 0) {
        popup.innerHTML = `
            <i class="fas fa-trophy congrats-icon"></i>
            <div class="congrats-message">Parabéns!</div>
            <div class="congrats-subtitle">Você completou seu check-in semanal</div>
            <div class="congrats-points" id="congratsPointsContainer">
                <i class="fas fa-star star-icon" id="congratsStarIcon"></i>
                <span>+${points} Pontos</span>
            </div>
        `;
    } else {
        popup.innerHTML = `
            <i class="fas fa-check-circle congrats-icon"></i>
            <div class="congrats-message">Check-in Completo!</div>
            <div class="congrats-subtitle">Seu check-in foi salvo com sucesso</div>
        `;
    }
    
    document.body.appendChild(popup);
    
    // Forçar reflow para garantir que a animação funcione
    popup.offsetHeight;
    
    // Se ganhou pontos, animar estrela voando para o badge
    if (points > 0) {
        // Esperar 2.5 segundos (quando popup está quase fechando) para iniciar animação
        setTimeout(() => {
            animateStarToBadge(points);
        }, 2500);
    }
    
    // Remover após a animação (3.5 segundos)
    setTimeout(() => {
        if (popup.parentNode) {
            popup.parentNode.removeChild(popup);
        }
    }, 3500);
}

function animateStarToBadge(points) {
    const starIcon = document.getElementById('congratsStarIcon');
    const pointsBadge = document.querySelector('.points-counter-badge');
    const pointsDisplay = document.getElementById('user-points-display');
    
    if (!starIcon || !pointsBadge || !pointsDisplay) {
        return;
    }
    
    // Obter posições EXATAS
    const starRect = starIcon.getBoundingClientRect();
    const badgeRect = pointsBadge.getBoundingClientRect();
    
    // Encontrar o ícone da estrela DENTRO do badge (não apenas o centro)
    const badgeStarIcon = pointsBadge.querySelector('i.fa-star');
    let endX, endY;
    
    if (badgeStarIcon) {
        // Se encontrou o ícone, usar sua posição exata
        const badgeStarRect = badgeStarIcon.getBoundingClientRect();
        endX = badgeStarRect.left + badgeStarRect.width / 2;
        endY = badgeStarRect.top + badgeStarRect.height / 2;
    } else {
        // Fallback: centro do badge
        endX = badgeRect.left + badgeRect.width / 2;
        endY = badgeRect.top + badgeRect.height / 2;
    }
    
    // Posição inicial (centro do ícone da estrela no popup)
    const startX = starRect.left + starRect.width / 2;
    const startY = starRect.top + starRect.height / 2;
    
    // Calcular distância total
    const deltaX = endX - startX;
    const deltaY = endY - startY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    // Duração baseada na distância
    const baseDuration = 1800;
    const duration = Math.min(Math.max(baseDuration, distance * 0.8), 2500);
    
    // Obter valor atual dos pontos
    const currentPointsText = pointsDisplay.textContent.replace(/\./g, '').replace(/,/g, '');
    const currentPoints = parseInt(currentPointsText) || 0;
    
    // Criar estrela voadora
    const flyingStar = document.createElement('div');
    flyingStar.className = 'flying-star';
    flyingStar.innerHTML = '<i class="fas fa-star"></i>';
    // Posicionar inicialmente usando left/top para garantir que fique na posição correta
    flyingStar.style.left = `${startX}px`;
    flyingStar.style.top = `${startY}px`;
    flyingStar.style.transform = 'translate(-50%, -50%) scale(1) rotate(0deg)';
    flyingStar.style.willChange = 'transform, opacity';
    
    document.body.appendChild(flyingStar);
    
    // Forçar reflow
    flyingStar.offsetHeight;
    
    // Função de easing tipo videogame
    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    // Animação com requestAnimationFrame
    // RECALCULA POSIÇÕES EM TEMPO REAL para acompanhar scroll
    const startTime = performance.now();
    let animationFrameId;
    
    function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // RECALCULAR posição final do badge EM TEMPO REAL (para acompanhar scroll)
        let currentEndX, currentEndY;
        const currentBadgeRect = pointsBadge.getBoundingClientRect();
        const currentBadgeStarIcon = pointsBadge.querySelector('i.fa-star');
        
        if (currentBadgeStarIcon) {
            const currentBadgeStarRect = currentBadgeStarIcon.getBoundingClientRect();
            currentEndX = currentBadgeStarRect.left + currentBadgeStarRect.width / 2;
            currentEndY = currentBadgeStarRect.top + currentBadgeStarRect.height / 2;
        } else {
            currentEndX = currentBadgeRect.left + currentBadgeRect.width / 2;
            currentEndY = currentBadgeRect.top + currentBadgeRect.height / 2;
        }
        
        // RECALCULAR posição inicial também (caso elemento fonte tenha se movido)
        const currentStarRect = starIcon.getBoundingClientRect();
        const currentStartX = currentStarRect.left + currentStarRect.width / 2;
        const currentStartY = currentStarRect.top + currentStarRect.height / 2;
        
        // Calcular delta atualizado
        const currentDeltaX = currentEndX - currentStartX;
        const currentDeltaY = currentEndY - currentStartY;
        const currentDistance = Math.sqrt(currentDeltaX * currentDeltaX + currentDeltaY * currentDeltaY);
        
        // Easing suave
        const easedProgress = easeOutCubic(progress);
        
        // Calcular posição atual baseada nas posições RECALCULADAS
        const currentX = currentStartX + (currentDeltaX * easedProgress);
        const currentY = currentStartY + (currentDeltaY * easedProgress);
        
        // Adicionar curva suave (parábola) - reduzida para evitar tremores
        const curveHeight = Math.min(currentDistance * 0.12, 80);
        const curveProgress = Math.sin(progress * Math.PI);
        const curveOffset = -curveHeight * curveProgress;
        
        // ESCALA SUAVIZADA - evitar mudanças bruscas
        let scale;
        if (progress < 0.2) {
            // Início: escala aumenta suavemente
            const scaleProgress = progress / 0.2;
            scale = 1 + (0.3 * easeOutCubic(scaleProgress));
        } else if (progress < 0.75) {
            // Meio: escala diminui suavemente
            const scaleProgress = (progress - 0.2) / 0.55;
            const easedScaleProgress = easeOutCubic(scaleProgress);
            scale = 1.3 - (0.4 * easedScaleProgress);
        } else {
            // Final: escala aumenta ligeiramente antes de desaparecer
            const finalProgress = (progress - 0.75) / 0.25;
            const easedFinalProgress = easeOutCubic(finalProgress);
            scale = 0.9 + (0.2 * easedFinalProgress);
        }
        
        // Rotação dinâmica - suavizada
        const rotation = progress * 360 * 1.5;
        
        // Opacidade (fade out suave no final)
        let opacity = 1;
        if (progress > 0.9) {
            opacity = 1 - ((progress - 0.9) / 0.1);
        }
        
        // Usar left/top + transform para garantir que a estrela não saia da viewport
        flyingStar.style.left = `${currentX}px`;
        flyingStar.style.top = `${currentY + curveOffset}px`;
        flyingStar.style.transform = `translate(-50%, -50%) scale(${scale}) rotate(${rotation}deg)`;
        flyingStar.style.opacity = opacity;
        
        // Continuar ou finalizar
        if (progress < 1) {
            animationFrameId = requestAnimationFrame(animate);
        } else {
            // Animação completa
            if (flyingStar.parentNode) {
                flyingStar.parentNode.removeChild(flyingStar);
            }
            
            // Atualizar pontos
            const checkinData = window.lastCheckinResponse || {};
            const newTotalPoints = checkinData.new_total_points;
            const newPoints = newTotalPoints !== undefined ? newTotalPoints : (currentPoints + points);
            
            // Adicionar classe de animação no badge
            pointsBadge.classList.add('points-updated');
            
            // Animar contagem dos pontos
            pointsDisplay.classList.add('points-counting');
            
            // Atualizar valor com animação de contagem
            animatePointsCount(pointsDisplay, currentPoints, newPoints, 1500);
            
            // Remover classes de animação após animação
            setTimeout(() => {
                pointsBadge.classList.remove('points-updated');
                pointsDisplay.classList.remove('points-counting');
            }, 2000);
        }
    }
    
    // Iniciar animação
    animationFrameId = requestAnimationFrame(animate);
    flyingStar._animationId = animationFrameId;
}

function animatePointsCount(element, startValue, endValue, duration) {
    const startTime = performance.now();
    const formatNumber = (num) => new Intl.NumberFormat('pt-BR').format(num);
    
    // Usar easing mais suave (ease-in-out cubic)
    function easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    
    function update(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing mais fluido
        const easedProgress = easeInOutCubic(progress);
        
        const currentValue = Math.floor(startValue + (endValue - startValue) * easedProgress);
        element.textContent = formatNumber(currentValue);
        
        if (progress < 1) {
            requestAnimationFrame(update);
        } else {
            // Garantir valor final exato
            element.textContent = formatNumber(endValue);
        }
    }
    
    requestAnimationFrame(update);
}

// ========================================
// CARREGAR E RENDERIZAR DASHBOARD
// ========================================
(async function() {
    const BASE_URL = window.BASE_APP_URL;
    console.log('BASE_URL:', BASE_URL);
    console.log('Token no localStorage:', getAuthToken() ? 'SIM' : 'NÃO');
    
    // Verificar se há token na URL (vindo do login.php)
    const urlParams = new URLSearchParams(window.location.search);
    const tokenFromUrl = urlParams.get('token');
    if (tokenFromUrl) {
        console.log('Token encontrado na URL, salvando...');
        // Salvar token no localStorage
        setAuthToken(tokenFromUrl);
        // Remover token da URL
        window.history.replaceState({}, document.title, window.location.pathname);
    }
    
    // Verificar autenticação
    console.log('Verificando autenticação...');
    const authenticated = await requireAuth();
    console.log('Autenticado?', authenticated);
    if (!authenticated) {
        console.log('Não autenticado, redirecionando...');
        return;
    }
    
    try {
        // Carregar dados do dashboard
        console.log('Carregando dashboard de:', `${BASE_URL}/api/get_dashboard_data.php`);
        const response = await authenticatedFetch(`${BASE_URL}/api/get_dashboard_data.php`);
        if (!response) {
            console.error('Response é null - token inválido ou erro de autenticação');
            return;
        }
        
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers.get('content-type'));
        
        // Clonar a resposta para poder ler como texto E como JSON
        const responseClone = response.clone();
        
        // Ler como texto para debug (sem consumir a resposta original)
        const responseText = await responseClone.text();
        console.log('Response text (primeiros 500 chars):', responseText.substring(0, 500));
        
        // Verificar se a resposta é JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            console.error('Resposta não é JSON. Conteúdo completo:', responseText);
            throw new Error('A API retornou um formato inválido. Verifique o console para mais detalhes.');
        }
        
        // Tentar fazer parse do JSON da resposta original
        let result;
        try {
            result = await response.json();
        } catch (parseError) {
            console.error('Erro ao fazer parse do JSON:', parseError);
            console.error('Texto recebido:', responseText);
            throw new Error('Resposta da API não é JSON válido. Verifique o console.');
        }
        console.log('Result:', result);
        
        if (!result.success) {
            throw new Error(result.message || 'Erro ao carregar dados');
        }
        
        const data = result.data;
        
        // Renderizar dashboard
        renderDashboard(data);
        
        // Mostrar container
        document.getElementById('dashboard-container').style.display = 'block';
        
    } catch (error) {
        console.error('Erro ao carregar dashboard:', error);
        console.error('Stack:', error.stack);
        const errorMsg = error.message || 'Erro desconhecido';
        document.getElementById('dashboard-container').innerHTML = `
            <div style="text-align: center; padding: 40px; color: var(--text-primary);">
                <p>Erro ao carregar dados: ${errorMsg}</p>
                <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 10px;">Verifique o console para mais detalhes.</p>
            </div>
        `;
        document.getElementById('dashboard-container').style.display = 'block';
    }
})();

// Re-executar quando carregado via SPA
window.addEventListener('spa-page-loaded', function(e) {
    if (e.detail && e.detail.isSPANavigation) {
        const pageName = window.location.pathname.split('/').pop();
        if (pageName === 'main_app.html' || pageName === 'dashboard.html') {
            // Verificar se o dashboard precisa ser recarregado
            const dashboardContainer = document.getElementById('dashboard-container');
            if (dashboardContainer) {
                // Re-executar o código de carregamento
                setTimeout(() => {
                    (async function() {
                        const BASE_URL = window.BASE_APP_URL;
                        const authenticated = await requireAuth();
                        if (!authenticated) return;
                        
                        try {
                            const response = await authenticatedFetch(`${BASE_URL}/api/get_dashboard_data.php`);
                            if (!response) return;
                            
                            const result = await response.json();
                            if (!result.success) {
                                throw new Error(result.message || 'Erro ao carregar dados');
                            }
                            
                            const data = result.data;
                            renderDashboard(data);
                            dashboardContainer.style.display = 'block';
                        } catch (error) {
                            console.error('Erro ao recarregar dashboard via SPA:', error);
                        }
                    })();
                }, 100);
            }
        }
    }
});

function renderDashboard(data) {
    // Atualizar pontos
    const pointsDisplay = document.getElementById('user-points-display');
    if (pointsDisplay && data.points !== undefined) {
        pointsDisplay.textContent = new Intl.NumberFormat('pt-BR').format(data.points);
    }
    
    // Atualizar avatar
    const profileIcon = document.getElementById('profile-icon-link');
    if (profileIcon && data.profile_image) {
        const img = profileIcon.querySelector('img') || document.createElement('img');
        img.src = `${window.BASE_APP_URL}/assets/images/users/${data.profile_image}`;
        img.alt = 'Foto de Perfil';
        img.onerror = function() {
            // Se a imagem falhar, tentar thumbnail
            this.onerror = null;
            this.src = `${window.BASE_APP_URL}/assets/images/users/thumb_${data.profile_image}`;
            this.onerror = function() {
                // Se thumbnail também falhar, mostrar ícone
                this.style.display = 'none';
                const icon = profileIcon.querySelector('i') || document.createElement('i');
                icon.className = 'fas fa-user';
                icon.style.display = 'flex';
                if (!profileIcon.querySelector('i')) {
                    profileIcon.appendChild(icon);
                }
            };
        };
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        if (!profileIcon.querySelector('img')) {
            profileIcon.innerHTML = '';
            profileIcon.appendChild(img);
        }
    }
    
    // Renderizar card de peso
    renderWeightCard(data);
    
    // Renderizar hidratação
    renderHydration(data);
    
    // Renderizar consumo
    renderConsumption(data);
    
    // Renderizar rotinas/missões
    renderRoutines(data);
    
    // Renderizar ranking
    renderRanking(data);
    
    // Renderizar sugestões de refeições
    renderMealSuggestions(data);
    
    // Renderizar desafios
    renderChallenges(data);
    
    // Mostrar botão de check-in se disponível
    if (data.available_checkin) {
        const checkinBtn = document.getElementById('checkin-floating-btn');
        const checkinModal = document.getElementById('checkinModal');
        
        if (checkinBtn) {
            checkinBtn.style.display = 'flex';
        }
        
        // Inicializar dados do checkin
        if (data.available_checkin) {
            window.checkinData = data.available_checkin;
            checkinData = data.available_checkin;
            
            // Atualizar título do modal se existir
            const checkinTitle = document.getElementById('checkin-title');
            if (checkinTitle && data.available_checkin.name) {
                checkinTitle.textContent = data.available_checkin.name;
            }
            
            // Garantir que o modal está disponível (remover display: none se estiver)
            if (checkinModal) {
                checkinModal.style.display = '';
            }
        }
    } else {
        // Esconder botão e modal se não houver checkin disponível
        const checkinBtn = document.getElementById('checkin-floating-btn');
        const checkinModal = document.getElementById('checkinModal');
        if (checkinBtn) {
            checkinBtn.style.display = 'none';
        }
        if (checkinModal) {
            checkinModal.style.display = 'none';
        }
    }
    
    // Inicializar carrossel de missões após renderizar
    setTimeout(() => {
        initializeMissionsCarousel();
    }, 100);
}

function renderWeightCard(data) {
    const weightCard = document.getElementById('weight-card');
    if (!weightCard) return;
    
    const weightData = data.weight_banner || {};
    let currentWeight = weightData.current_weight || '--';
    // Remover "kg" se estiver no formato string
    if (typeof currentWeight === 'string' && currentWeight.endsWith('kg')) {
        currentWeight = currentWeight.replace('kg', '').trim();
    }
    const daysUntil = weightData.days_until_update || weightData.days_until_next_weight_update || 0;
    const showEdit = weightData.show_edit_button !== false;
    
    let html = '';
    
    if (showEdit) {
        // Mostrar peso atual com botão de editar
        html += `<span>Peso Atual</span>`;
        html += `<strong id="current-weight-value">${typeof currentWeight === 'number' ? currentWeight.toFixed(1).replace('.', ',') : currentWeight}kg</strong>`;
        html += `<button data-action="open-weight-modal" class="edit-button" aria-label="Editar peso">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>
        </button>`;
    } else {
        // Mostrar countdown de próxima atualização
        html += `<span>Próxima atualização em</span>`;
        html += `<strong class="countdown">${daysUntil} ${daysUntil === 1 ? 'dia' : 'dias'}</strong>`;
    }
    
    weightCard.innerHTML = html;
}

function renderHydration(data) {
    const waterData = data.water || {};
    const waterConsumed = (waterData.consumed_cups || 0) * (waterData.cup_size_ml || 250);
    const waterGoal = waterData.goal_ml || 2000;
    
    // Atualizar display
    const waterAmountDisplay = document.getElementById('water-amount-display');
    const waterGoalDisplay = document.getElementById('water-goal-display');
    if (waterAmountDisplay) waterAmountDisplay.textContent = Math.round(waterConsumed);
    if (waterGoalDisplay) waterGoalDisplay.textContent = `${Math.round(waterGoal)} ml`;
    
    // Atualizar gota d'água
    const waterLevelGroup = document.getElementById('water-level-group');
    if (waterLevelGroup) {
        const percentage = waterGoal > 0 ? Math.min(waterConsumed / waterGoal, 1) : 0;
        const dropHeight = 275.785;
        const yTranslate = dropHeight * (1 - percentage);
        waterLevelGroup.setAttribute('transform', `translate(0, ${yTranslate})`);
    }
    
    // Atualizar variável global para os controles
    window.currentWater = waterConsumed;
}

function renderConsumption(data) {
    const summary = data.daily_summary || {};
    
    const kcal = summary.kcal?.consumed || 0;
    const protein = summary.protein?.consumed || 0;
    const carbs = summary.carbs?.consumed || 0;
    const fat = summary.fat?.consumed || 0;
    
    const kcalGoal = summary.kcal?.goal || 2000;
    const proteinGoal = summary.protein?.goal || 150;
    const carbsGoal = summary.carbs?.goal || 200;
    const fatGoal = summary.fat?.goal || 65;
    
    // Atualizar círculo de calorias
    updateCaloriesCircle(kcal, kcalGoal);
    
    // Atualizar barras de macros
    updateMacroBar('carbs', carbs, carbsGoal);
    updateMacroBar('protein', protein, proteinGoal);
    updateMacroBar('fat', fat, fatGoal);
}

function updateCaloriesCircle(value, goal) {
    const circleElement = document.getElementById('kcal-circle');
    if (!circleElement) return;
    
    const percentage = goal > 0 ? Math.min(Math.max(value / goal, 0), 1) : 0;
    const circle = circleElement.querySelector('.circle');
    const valueDisplay = document.getElementById('kcal-value-display');
    
    if (circle) {
        // Calcular a circunferência do círculo (raio = 15.9155 no viewBox 40x40)
        const radius = 15.9155;
        const circumference = 2 * Math.PI * radius;
        
        // Configurar stroke-dasharray e stroke-dashoffset
        circle.style.strokeDasharray = `${circumference} ${circumference}`;
        circle.style.strokeDashoffset = circumference - (percentage * circumference);
        circle.style.visibility = 'visible';
        circle.style.opacity = '1';
    }
    
    if (valueDisplay) {
        valueDisplay.textContent = Math.round(value);
    }
}

function updateMacroBar(type, value, goal) {
    const valueEl = document.getElementById(`${type}-value-display`);
    const goalEl = document.getElementById(`${type}-goal-display`);
    const progressBar = document.getElementById(`${type}-progress-bar`);
    
    if (valueEl) {
        valueEl.textContent = Math.round(value);
    }
    
    if (goalEl) {
        goalEl.textContent = Math.round(goal);
    }
    
    if (progressBar) {
        const percentage = goal > 0 ? Math.min(Math.max((value / goal) * 100, 0), 100) : 0;
        progressBar.style.width = `${percentage}%`;
    }
}

function renderRoutines(data) {
    const missionsCard = document.getElementById('missions-card');
    if (!missionsCard) return;
    
    const routineData = data.routine || {};
    const routines = routineData.items || [];
    const completedCount = routineData.completed_missions || 0;
    const totalCount = routineData.total_missions || routines.length;
    
    // Atualizar progresso
    const progressText = document.getElementById('missions-progress-text');
    const progressBar = document.getElementById('missions-progress-bar');
    if (progressText) progressText.textContent = `${completedCount} de ${totalCount}`;
    if (progressBar) {
        const percentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;
        progressBar.style.width = `${percentage}%`;
    }
    
    // Atualizar variáveis globais
    completedMissionsCount = completedCount;
    totalMissionsCount = totalCount;
    
    // Renderizar slides de missões
    const missionsCarousel = document.getElementById('missions-carousel');
    if (!missionsCarousel) return;
    
    if (routines.length === 0) {
        missionsCard.style.display = 'none';
        return;
    }
    
    missionsCard.style.display = 'block';
    
    let html = '';
    const pendingRoutines = routines.filter(r => r.completion_status != 1);
    let firstPendingIndex = -1;
    
    routines.forEach((routine, index) => {
        const isCompleted = routine.completion_status == 1;
        if (!isCompleted && firstPendingIndex === -1) {
            firstPendingIndex = index;
        }
    });
    
    routines.forEach((routine, index) => {
        const isCompleted = routine.completion_status == 1;
        const missionId = routine.id || `routine_${index}`;
        const title = routine.title || 'Tarefa';
        const icon = routine.icon_class || 'fa-check-circle';
        const isExercise = routine.is_exercise == 1;
        const exerciseType = routine.exercise_type || '';
        const hasDuration = routine.duration_minutes !== null && routine.duration_minutes !== undefined;
        const duration = routine.duration_minutes || null;
        
        // Determinar se precisa de duração ou sono (igual ao main_app.php)
        let isDuration = false;
        let isSleep = false;
        
        if (String(missionId).indexOf('onboarding_') === 0) {
            // Exercício onboarding - sempre é duração
            isDuration = true;
        } else if (isExercise) {
            // Verificar se é sono ou duração baseado no exercise_type
            if (exerciseType === 'sleep') {
                isSleep = true;
            } else if (exerciseType === 'duration') {
                isDuration = true;
            }
        } else if (title.toLowerCase().indexOf('sono') !== -1) {
            // Fallback para verificação por título
            isSleep = true;
        }
        
        // Se é exercício onboarding, usar prefixo onboarding_
        const displayMissionId = isExercise && exerciseType === 'duration' ? `onboarding_${title}` : missionId;
        
        // Primeira missão pendente fica ativa
        const isFirstPending = index === firstPendingIndex && !isCompleted;
        
        html += `
            <div class="mission-slide ${isFirstPending ? 'active' : ''}" data-mission-id="${displayMissionId}" data-completed="${isCompleted ? '1' : '0'}">
                <div class="mission-icon">
                    <i class="fas ${icon}"></i>
                </div>
                <div class="mission-details">
                    <h4>${escapeHtml(title)}</h4>
                    <small class="mission-duration-display" style="display: none;"></small>
                </div>
                <div class="mission-actions">
                    <button class="mission-action-btn skip-btn" aria-label="Pular Missão"><i class="fas fa-times"></i></button>
                    ${isDuration ? `
                        <button class="mission-action-btn duration-btn" aria-label="Definir Duração" data-mission-id="${displayMissionId}">
                            <i class="fas fa-clock"></i>
                        </button>
                        <button class="mission-action-btn complete-btn disabled" aria-label="Completar Missão">
                            <i class="fas fa-check"></i>
                        </button>
                    ` : isSleep ? `
                        <button class="mission-action-btn sleep-btn" aria-label="Registrar Sono" data-mission-id="${displayMissionId}">
                            <i class="fas fa-clock"></i>
                        </button>
                        <button class="mission-action-btn complete-btn disabled" aria-label="Completar Missão">
                            <i class="fas fa-check"></i>
                        </button>
                    ` : `
                        <button class="mission-action-btn complete-btn" aria-label="Completar Missão">
                            <i class="fas fa-check"></i>
                        </button>
                    `}
                </div>
            </div>
        `;
    });
    
    // Adicionar card de conclusão se todas completas (igual ao main_app.php)
    if (completedCount === totalCount && totalCount > 0) {
        html += `
            <div class="mission-slide completion-message" id="all-missions-completed-card">
                <div class="mission-details"><h4>Parabéns!</h4><p>Você completou sua jornada de hoje.</p></div>
            </div>
        `;
    }
    
    // Limpar completamente antes de adicionar novo conteúdo
    missionsCarousel.innerHTML = '';
    
    // Adicionar novo HTML
    missionsCarousel.innerHTML = html;
    
    // Reconfigurar event listeners e variáveis após renderizar
    // Isso garante que não haja referências antigas
    missionSlides = Array.from(missionsCarousel.querySelectorAll('.mission-slide:not(.completion-message)'));
    completionCard = document.getElementById('all-missions-completed-card');
    pendingSlides = missionSlides.filter(slide => slide.dataset.completed === '0');
    
    // Garantir que apenas uma missão fique ativa
    showCurrentMission();
}

function renderRanking(data) {
    const rankingCard = document.getElementById('ranking-card');
    if (!rankingCard) return;
    
    const ranking = data.ranking || {};
    console.log('🔍 [Ranking] Dados recebidos:', ranking);
    console.log('🔍 [Ranking] Opponent data:', ranking.opponent);
    
    if (!ranking.my_rank || ranking.my_rank === 0) {
        rankingCard.style.display = 'none';
        return;
    }
    
    rankingCard.style.display = 'block';
    const BASE_URL = window.BASE_APP_URL;
    
    // 1. Renderizar foto do usuário (esquerda)
    const userAvatar = document.getElementById('user-avatar');
    if (userAvatar) {
        const profileImage = data.profile_image;
        if (profileImage) {
            // Tentar imagem original primeiro, depois thumbnail, depois ícone
            const imageUrl = `${BASE_URL}/assets/images/users/${profileImage}`;
            const thumbUrl = `${BASE_URL}/assets/images/users/thumb_${profileImage}`;
            userAvatar.innerHTML = `
                <img src="${imageUrl}" alt="Sua foto" onerror="this.onerror=null; this.src='${thumbUrl}'; this.onerror=function(){this.style.display='none'; this.nextElementSibling.style.display='flex';}">
                <i class="fas fa-user" style="display:none;"></i>
            `;
        } else {
            userAvatar.innerHTML = '<i class="fas fa-user"></i>';
        }
    }
    
    // 2. Atualizar título e posição
    const clashTitle = document.getElementById('clash-title');
    const myRankEl = document.getElementById('my-rank');
    const progressBar = document.getElementById('ranking-progress-bar');
    
    if (clashTitle) {
        if (ranking.my_rank == 1) {
            clashTitle.textContent = 'Você está no Topo!';
            clashTitle.classList.add('winner');
        } else {
            clashTitle.textContent = 'Disputa de Pontos';
            clashTitle.classList.remove('winner');
        }
    }
    
    if (myRankEl) {
        myRankEl.textContent = `${ranking.my_rank}º`;
    }
    
    if (progressBar && ranking.progress_percentage !== undefined) {
        progressBar.style.width = `${ranking.progress_percentage}%`;
    }
    
    // 3. Renderizar oponente (direita)
    const opponentInfo = document.getElementById('opponent-info');
    const opponentName = document.getElementById('opponent-name');
    
    // Verificar se há oponente (pode ser null ou objeto com dados)
    // No PHP: <?php if (isset($opponent_data)): ?>
    // A API retorna opponent_data que pode ser null ou um objeto
    console.log('🔍 [Ranking] Verificando oponente:', {
        hasOpponent: !!ranking.opponent,
        opponentIsNull: ranking.opponent === null,
        opponentName: ranking.opponent?.name,
        opponentImage: ranking.opponent?.profile_image_filename
    });
    
    // Verificar se há oponente (igual ao PHP: <?php if (isset($opponent_data)): ?>)
    // A API retorna opponent_data que pode ser null ou um objeto com id, name, points, profile_image_filename, etc.
    if (ranking.opponent && ranking.opponent !== null && typeof ranking.opponent === 'object' && ranking.opponent.name) {
        console.log('✅ [Ranking] Renderizando oponente:', ranking.opponent);
        
        // Mostrar oponente
        if (opponentInfo) {
            const opponentAvatar = opponentInfo.querySelector('.player-avatar');
            if (opponentAvatar) {
                const opponentImage = ranking.opponent.profile_image_filename;
                console.log('🖼️ [Ranking] Foto do oponente:', opponentImage);
                
                if (opponentImage) {
                    // Tentar imagem original primeiro, depois thumbnail, depois ícone (igual ao PHP)
                    const opponentImageUrl = `${BASE_URL}/assets/images/users/${opponentImage}`;
                    const opponentThumbUrl = `${BASE_URL}/assets/images/users/thumb_${opponentImage}`;
                    opponentAvatar.innerHTML = `
                        <img src="${opponentImageUrl}" alt="Foto do oponente" onerror="this.onerror=null; this.src='${opponentThumbUrl}'; this.onerror=function(){this.style.display='none'; this.nextElementSibling.style.display='flex';}">
                        <i class="fas fa-user" style="display:none;"></i>
                    `;
                } else {
                    console.log('⚠️ [Ranking] Oponente sem foto, usando ícone padrão');
                    opponentAvatar.innerHTML = '<i class="fas fa-user"></i>';
                }
            }
        }
        
        // Nome do oponente (apenas primeiro nome) - igual ao PHP: explode(' ', $opponent_data['name'])[0]
        if (opponentName && ranking.opponent.name) {
            const firstName = ranking.opponent.name.split(' ')[0];
            console.log('👤 [Ranking] Nome do oponente:', firstName);
            opponentName.textContent = firstName;
        }
    } else {
        // Se não há oponente, mostrar ícone padrão (igual ao PHP quando não há oponente)
        if (opponentInfo) {
            const opponentAvatar = opponentInfo.querySelector('.player-avatar');
            if (opponentAvatar) {
                opponentAvatar.innerHTML = '<i class="fas fa-user"></i>';
            }
        }
        if (opponentName) {
            opponentName.textContent = '-';
        }
    }
}

function renderMealSuggestions(data) {
    const mealCtaCard = document.getElementById('meal-cta-card');
    const suggestionsCard = document.getElementById('suggestions-card');
    
    const mealSuggestion = data.meal_suggestion || {};
    const suggestions = mealSuggestion.recipes || [];
    const BASE_URL = window.BASE_APP_URL;
    
    if (mealCtaCard) {
        const greeting = mealSuggestion.greeting || 'O que você vai comer agora?';
        const mealTypeId = mealSuggestion.db_param || mealSuggestion.meal_type_id || 'lunch';
        mealCtaCard.querySelector('h2').textContent = greeting;
        const addBtn = document.getElementById('add-meal-btn');
        if (addBtn) {
            // Função para obter data local (não UTC)
            function getLocalDateString() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
            const currentDate = getLocalDateString();
            addBtn.href = `./add_food_to_diary.html?meal_type=${mealTypeId}&date=${currentDate}`;
        }
    }
    
    if (suggestionsCard) {
        if (suggestions.length > 0) {
            suggestionsCard.style.display = 'block';
            
            // Atualizar título
            const titleEl = document.getElementById('suggestions-title');
            if (titleEl) {
                titleEl.innerHTML = `Sugestões para <span>${escapeHtml(mealSuggestion.display_name || 'Refeição')}</span>`;
            }
            
            // Atualizar link "Ver mais"
            const viewAllLink = document.getElementById('suggestions-view-all');
            if (viewAllLink && mealSuggestion.category_id) {
                viewAllLink.href = `./explore_recipes.html?categories=${mealSuggestion.category_id}`;
            }
            
            const carousel = document.getElementById('suggestions-carousel');
            if (carousel) {
                let html = '';
                suggestions.forEach(recipe => {
                    // Construir URL da imagem (usar image_url se disponível, senão construir)
                    const imageUrl = recipe.image_url 
                        || (recipe.image_filename 
                            ? `${BASE_URL}/assets/images/recipes/${recipe.image_filename}`
                            : `${BASE_URL}/assets/images/recipes/placeholder_food.jpg`);
                    
                    html += `
                        <div class="suggestion-item glass-card">
                            <a href="./view_recipe.html?id=${recipe.id}" class="suggestion-link">
                                <div class="suggestion-image-container">
                                    <img src="${imageUrl}" alt="${escapeHtml(recipe.name)}" onerror="this.src='${BASE_URL}/assets/images/recipes/placeholder_food.jpg'">
                                </div>
                                <div class="recipe-info">
                                    <h4>${escapeHtml(recipe.name)}</h4>
                                    <span><i class="fas fa-fire-alt"></i> ${Math.round(recipe.kcal_per_serving || 0)} kcal</span>
                                </div>
                            </a>
                        </div>
                    `;
                });
                carousel.innerHTML = html;
            }
        } else {
            // Mostrar mensagem de "nenhuma sugestão" igual ao PHP
            suggestionsCard.style.display = 'block';
            const carousel = document.getElementById('suggestions-carousel');
            if (carousel) {
                carousel.innerHTML = `
                    <div class="no-suggestions-card glass-card">
                        <p>Nenhuma sugestão para esta refeição no momento.</p>
                    </div>
                `;
            }
        }
    }
}

function renderChallenges(data) {
    const challengesCard = document.getElementById('challenges-card');
    if (!challengesCard) return;
    
    const challengeGroups = data.challenge_groups || [];
    const viewAllLink = document.getElementById('challenges-view-all');
    const emptyState = document.getElementById('challenges-empty-state');
    const challengesList = document.getElementById('challenges-list');
    
    if (challengeGroups.length === 0) {
        if (emptyState) emptyState.style.display = 'block';
        if (challengesList) challengesList.style.display = 'none';
        if (viewAllLink) viewAllLink.style.display = 'none';
        challengesCard.style.display = 'block';
        return;
    }
    
    challengesCard.style.display = 'block';
    if (emptyState) emptyState.style.display = 'none';
    if (viewAllLink) viewAllLink.style.display = 'block';
    if (challengesList) {
        challengesList.style.display = 'block';
        let html = '';
        
        challengeGroups.forEach(challenge => {
            // Calcular status e datas (igual ao PHP)
            const startDate = new Date(challenge.start_date);
            const endDate = new Date(challenge.end_date);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let currentStatus, statusText, statusColor;
            if (today < startDate) {
                currentStatus = 'scheduled';
                statusText = 'Agendado';
                statusColor = 'var(--text-secondary)';
            } else if (today >= startDate && today <= endDate) {
                currentStatus = 'active';
                statusText = 'Em andamento';
                statusColor = 'var(--accent-orange)';
            } else {
                currentStatus = 'completed';
                statusText = 'Concluído';
                statusColor = '#4CAF50';
            }
            
            // Calcular progresso (dias)
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
            const daysPassed = today > startDate ? Math.ceil((today - startDate) / (1000 * 60 * 60 * 24)) : 0;
            const daysRemaining = Math.max(0, Math.ceil((endDate - today) / (1000 * 60 * 60 * 24)));
            const progressPercentage = totalDays > 0 ? Math.min(100, Math.round((daysPassed / totalDays) * 100)) : 0;
            
            // Formatar datas
            const formatDate = (date) => {
                const d = new Date(date);
                const day = String(d.getDate()).padStart(2, '0');
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const year = d.getFullYear();
                return `${day}/${month}/${year}`;
            };
            
            html += `
                <a href="./challenges.html?id=${challenge.id}" class="challenge-item">
                    <div class="challenge-item-header">
                        <h4>${escapeHtml(challenge.name)}</h4>
                        <span class="challenge-status" style="color: ${statusColor};">
                            ${escapeHtml(statusText)}
                        </span>
                    </div>
                    ${challenge.description ? `
                        <p class="challenge-description">${escapeHtml(challenge.description.length > 100 ? challenge.description.substring(0, 100) + '...' : challenge.description)}</p>
                    ` : ''}
                    <div class="challenge-meta">
                        <span class="challenge-date">
                            <i class="fas fa-calendar"></i>
                            ${formatDate(challenge.start_date)} - ${formatDate(challenge.end_date)}
                        </span>
                        <span class="challenge-participants">
                            <i class="fas fa-users"></i>
                            ${challenge.total_participants || 0} participante${(challenge.total_participants || 0) > 1 ? 's' : ''}
                        </span>
                    </div>
                    ${currentStatus === 'active' ? `
                        <div class="challenge-progress">
                            <div class="challenge-progress-info">
                                <span>${daysRemaining} dia${daysRemaining > 1 ? 's' : ''} restante${daysRemaining > 1 ? 's' : ''}</span>
                                <span>${progressPercentage}%</span>
                            </div>
                            <div class="progress-bar-challenge">
                                <div class="progress-bar-challenge-fill" style="width: ${progressPercentage}%;"></div>
                            </div>
                        </div>
                    ` : ''}
                    ${challenge.goals && challenge.goals.length > 0 ? `
                        <div class="challenge-goals-preview">
                            ${challenge.goals.map(goal => {
                                const goalIcons = {
                                    'calories': 'fas fa-fire',
                                    'water': 'fas fa-tint',
                                    'exercise': 'fas fa-dumbbell',
                                    'sleep': 'fas fa-bed'
                                };
                                const goalLabels = {
                                    'calories': 'Calorias',
                                    'water': 'Água',
                                    'exercise': 'Exercício',
                                    'sleep': 'Sono'
                                };
                                const icon = goalIcons[goal.type] || 'fas fa-bullseye';
                                const label = goalLabels[goal.type] || goal.type.charAt(0).toUpperCase() + goal.type.slice(1);
                                let unit = '';
                                if (goal.value) {
                                    if (goal.type === 'calories') unit = 'kcal';
                                    else if (goal.type === 'water') unit = 'ml';
                                    else if (goal.type === 'exercise') unit = 'min';
                                    else if (goal.type === 'sleep') unit = 'h';
                                }
                                return `
                                    <span class="challenge-goal-badge">
                                        <i class="${icon}"></i>
                                        ${escapeHtml(label)}
                                        ${goal.value ? `<span>${goal.value}${unit}</span>` : ''}
                                    </span>
                                `;
                            }).join('')}
                        </div>
                    ` : ''}
                </a>
            `;
        });
        
        challengesList.innerHTML = html;
    }
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Event listener para salvar peso
document.addEventListener('DOMContentLoaded', function() {
    const saveWeightBtn = document.getElementById('save-weight-btn');
    if (saveWeightBtn) {
        saveWeightBtn.addEventListener('click', async function() {
            const input = document.getElementById('new-weight-input');
            const weight = parseFloat(input.value);
            
            if (!weight || weight <= 0) {
                alert('Por favor, insira um peso válido.');
                return;
            }
            
            try {
                // IMPORTANTE: Não enviar data do cliente - o servidor deve usar sua própria data/hora
                // para validar a restrição de 7 dias. Isso previne que usuários burlem mudando a data do celular.
                const response = await authenticatedFetch(`${window.BASE_APP_URL}/api/update_weight.php`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ weight_kg: weight })
                    // NÃO enviar data - servidor usa sua própria data/hora para validação
                });
                
                if (!response) return;
                
                const result = await response.json();
                if (result.success) {
                    const modal = document.getElementById('edit-weight-modal');
                    if (modal) {
                        modal.classList.remove('modal-visible');
                        document.body.style.overflow = '';
                    }
                    // Recarregar página para atualizar dados
                    window.location.reload();
                } else {
                    alert(result.message || 'Erro ao atualizar peso.');
                }
            } catch (error) {
                console.error('Erro:', error);
                alert('Erro ao atualizar peso. Tente novamente.');
            }
        });
    }
    
    // Abrir modal de peso ao clicar no botão
    document.addEventListener('click', function(e) {
        if (e.target.closest('[data-action="open-weight-modal"]')) {
            const modal = document.getElementById('edit-weight-modal');
            if (modal) {
                modal.classList.add('modal-visible');
                document.body.style.overflow = 'hidden';
                // Preencher input com peso atual
                const currentWeightEl = document.getElementById('current-weight-value');
                if (currentWeightEl) {
                    const currentWeightText = currentWeightEl.textContent.replace('kg', '').trim().replace(',', '.');
                    const weightInput = document.getElementById('new-weight-input');
                    if (weightInput) {
                        weightInput.value = parseFloat(currentWeightText) || '';
                    }
                }
            }
        }
        // Fechar modal ao clicar fora ou no botão cancelar
        if (e.target.closest('[data-action="close-modal"]') || e.target.id === 'edit-weight-modal') {
            const modal = document.getElementById('edit-weight-modal');
            if (modal) {
                modal.classList.remove('modal-visible');
                document.body.style.overflow = '';
            }
        }
    });
});

// Adicionar CSRF token hidden input (necessário para algumas ações)
if (!document.getElementById('csrf_token_main_app')) {
    const csrfInput = document.createElement('input');
    csrfInput.type = 'hidden';
    csrfInput.id = 'csrf_token_main_app';
    csrfInput.value = ''; // Será preenchido se necessário
    document.body.appendChild(csrfInput);
}

</script>

<!-- Scripts do carrossel de banners -->
<script src="./assets/js/banner-carousel.js"></script>

</body>
</html>
